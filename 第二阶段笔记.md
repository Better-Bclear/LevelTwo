# 第二阶段笔记

## 第一章Mysql

### 一、引言

### 二、并发

*SQL-A:*

```routeros
update useraccount t set t.account=t.account+100 where username='wudimanong';
```

*SQL-B:*

```routeros
update useraccount t set t.account=t.account-100 where username='wudimanong'
```

那么在MySQL中是如何进行并发控制的呢？实际上与大多数并发控制方式一样，在MySQL中也是利用锁机制来实现并发控制的。

**1.MySQL锁类型**

在MySQL中主要是通过"读写锁"来实现并发控制。

**读锁(read lock)：**也叫共享锁(share lock)，多个读请求可以同时共享一把锁来读取数据，而不会造成阻塞。

**写锁(write lock)：**也叫排他锁(exclusive lock)，写锁会排斥其他所有获取锁的请求，一直阻塞，直到完成写入并释放锁。

读写锁可以做到读读并行，但是无法做到写读、写写并行。后面会讲到的事务隔离性就是根据读写锁来实现的！

**2.MySQL锁粒度**

上面提及的读写锁是根据MySQL的锁类型来划分的，而读写锁能够施加的粒度在数据库中主要体现为表和行，也称为*表锁(table lock)、行锁(row lock)*。

**表锁(table lock)**：是MySQL中最基本的锁策略，它会锁定整张表，这样维护锁的开销最小，但是会降低表的读写效率。如果一个用户通过表锁来实现对表的写操作(插入、删除、更新)，那么先需要获得锁定该表的写锁，那么在这种情况下，其他用户对该表的读写都会被阻塞。一般情况下"alter table"之类的语句才会使用表锁。

**行锁(row lock)**：行锁可以最大程度地支持并发读写，但数据库维护锁的开销会比较大。行锁是我们日常使用最多的锁策略，一般情况下MySQL中的行级锁由具体的存储引擎实现，而不是MySQL服务器层面去实现(表锁MySQL服务器层面会实现)。

**3.多版本并发控制(MVCC)**

MVCC(MultiVersion Concurrency Control)，多版本并发控制。在MySQL的大多数事务引擎(如InnoDB)中，都不只是简单地实现了行级锁，否则会出现这样的情况：*"数据A被某个用户更新期间(获取行级写锁),其他用户读取该条数据(获取读锁)都会被阻塞*“。但现实情况显然不是这样，这是因为MySQL的存储引擎基于提升并发性能的考虑，通过MVCC数据多版本控制，做到了读写分离，从而实现不加锁读取数据进而做到了读写并行。

以InnoDB存储引擎的MVCC实现为例：

> InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存了行的过期时间。当然它们存储的并不是实际的时间值，而是系统版本号。每开启一个新的事务，系统版本号都会自动递增；事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

MVCC在MySQL中实现所依赖的手段主要是:"**undo log和read view**"。

- undo log :undo log 用于记录某行数据的多个版本的数据。
- read view :用来判断当前版本数据的可见性

### 三、查询

#### 1.基本查询

##### (1).简单查询

> 语法：SELECT 字段名1,字段名2,... from 表名

```sql
-- 查询工号
SELECT employee_id from employees;
-- 查询工号、姓名、邮箱、工号
SELECT employee_id,first_name,last_name,email,job_id from employees;
#不推荐
SELECT * from employees;
-- 拼接字符
SELECT employee_id,CONCAT(first_name,' ',last_name) name FROM employees
-- 注意：字符串用单引号和双引号都可以
```

##### (2).排序

> 语法：SELECT 字段名1,字段名2,... from 表名 order by 字段名 asc(升序)|desc(降序),字段名2 asc|desc
>
> **注意：不写升序还是降序默认是升序**

```sql
-- 排序
-- 注意：如果是升序，asc 可以省略
-- 工资从小到大
SELECT employee_id,CONCAT(first_name,' ',last_name),salary FROM employees ORDER BY salary;
-- 工资从大到小
SELECT employee_id,CONCAT(first_name,' ',last_name),salary FROM employees ORDER BY salary DESC;
-- 查询工号、姓名、工资并按照工资从大到小，工资相同则工号从大到小
SELECT employee_id,CONCAT(first_name,' ',last_name),salary FROM employees ORDER BY salary DESC,employee_id DESC;
```

##### (3).条件查询

(1)基本查询

> 基本语法：SELECT 字段名1,字段名2,... from 表名 WHERE 字段名 查询条件
>
> 不等于：!=,大于：>,大于等于：>=,小于：<,小于等于：<=,并且：and,或者：or
>
> not：语句代表与后面的查询条件相反的数据
>
> is null：查询某个字段为空

```sql
-- 条件查询
-- 查询工资为17000的员工的姓名和id
SELECT employee_id,CONCAT(first_name,' ',last_name),salary FROM employees WHERE salary = 17000;
-- 查询last_name为King
SELECT employee_id,CONCAT(first_name,' ',last_name),salary FROM employees WHERE last_name = 'king';
-- 不等于：!=,大于：>,大于等于：>=,小于：<,小于等于：<=,并且：and,或者：or
-- 查询last_name不为King
SELECT employee_id,CONCAT(first_name,' ',last_name),salary FROM employees WHERE last_name != 'king';
-- 工资大于等于17000且小于等于24000
SELECT employee_id,CONCAT(first_name,' ',last_name),salary FROM employees WHERE salary >= 17000 AND salary <=24000;
```

(2)between and 查询

> **语法：SELECT 字段名1,... FROM 表名 WHERE 字段名 BETWEEN 最小值 AND 最大值**
>
> **注意：BETWEEN AND(左右都是闭区间)**

```sql
SELECT employee_id,CONCAT(first_name,' ',last_name),salary FROM employees WHERE salary BETWEEN 17000 AND 24000;
-- 查工资不在这个范围的
SELECT employee_id,CONCAT(first_name,' ',last_name),salary FROM employees WHERE salary < 17000 OR salary > 24000;
-- [NOT] BETWEEN 小值 AND 大值 不在此区间的数据
SELECT employee_id,CONCAT(first_name,' ',last_name),salary FROM employees WHERE salary NOT BETWEEN 17000 AND 24000;
```

(3)in语句

> **语法：select 字段名1,... FROM 表名 WHERE 字段名 in(值1，值2，...)**

```sql
-- 查询员工部门是90号 或 60号 或 100号部门的员工
SELECT employee_id,CONCAT(first_name,' ',last_name),salary,department_id FROM employees WHERE department_id = 90 OR department_id = 60 OR department_id = 100;
-- in(值1，值2，...) 简化代码
SELECT employee_id,CONCAT(first_name,' ',last_name),salary,department_id FROM employees WHERE department_id IN(60,90,100);
-- 查询员工不在上述范围的[NOT] IN
SELECT employee_id,CONCAT(first_name,' ',last_name),salary,department_id FROM employees WHERE department_id NOT IN(60,90,100);
```

(4)模糊查询

> **语法：SELECT 字段名1,... FROM 表名 WHERE 字段名 LIKE 格式字符串**
>
> 格式字符串：包含字符常量和通配符
>
> 通配符：%代表0～n个任意字符 _代表任意一个字符

```sql
-- 查询last_name为K开头的员工 King匹配 K12匹配 AKDD不匹配
SELECT employee_id,CONCAT(first_name,' ',last_name),salary,department_id FROM employees WHERE last_name LIKE 'K%';
-- 查询last_name不以K开头的员工
SELECT employee_id,CONCAT(first_name,' ',last_name),salary,department_id FROM employees WHERE last_name NOT LIKE 'K%';
-- 查询last_name倒数第三个为a的员工
SELECT employee_id,CONCAT(first_name,' ',last_name),salary,department_id FROM employees WHERE last_name LIKE '%a__';
-- 查询last_name倒数第三个为a,且名字的长度必须为4
SELECT employee_id,CONCAT(first_name,' ',last_name),salary,department_id FROM employees WHERE last_name LIKE '_a__';
-- 查询last_name以a结尾的
SELECT employee_id,CONCAT(first_name,' ',last_name),salary,department_id FROM employees WHERE last_name LIKE '%a';
```

### 四、组函数

#### 一、单行函数

> 补充：为了方便测试单行函数。我们创建一张表。里面只有一个字段，总共一个数据。
>
> dual：哑表
>
> 概念：函数作用于表中的每一行数据，有一行数据函数就会执行
>
> 1.`now()`：获取当前系统时间
>
> 2.`DATE_FORMAT(日期类型的数据,日期类型的字符串)`：将日期转换为指定的字符串
>
> ​	日期格式化字符串：
>
> ​			%Y--4位的年
>
> ​			%y--2位的年
>
> ​			%m--2位的月
>
> ​			%d--2位的日
>
> ​			%H--2位的小时(24小时制)
>
> ​			%h--2位的小时(12小时制)
>
> ​			%i--2位的分钟
>
> ​			%s--两位的秒
>
> 3.`STR_TO_DATE(str,format)`：将指定的字符串转换成日期，第一个参数是字符串，第二个参数是转换格式

```sql
-- 获取当前系统时间
SELECT NOW() FROM employees; -- 107条数据
SELECT NOW() FROM DUAL;-- 一条数据
```

```sql
-- DATE_FORMAT(日期类型的数据,日期类型的字符串)；将日期转换为指定的字符串
SELECT DATE_FORMAT(NOW(),'%y年%m月%d日 %H时%m分%S秒') '当前时间' FROM DUAL;
-- 查询1992年下半年入职的员工
SELECT employee_id,CONCAT(first_name,' ',last_name),salary,department_id,hiredate FROM employees WHERE DATE_FORMAT(hiredate,'%Y') = '1992' AND DATE_FORMAT(hiredate,'%m')>6;
SELECT employee_id,CONCAT(first_name,' ',last_name),salary,department_id,hiredate FROM employees WHERE YEAR(hiredate)=1992 AND MONTH(hiredate)>6;
```

```sql
-- STR_TO_DATE(str,format)：将指定的字符串转换成日期，第一个参数是字符串，第二个参数是转换格式
-- '2012年12月12日'转日期
SELECT STR_TO_DATE('2012年12月12日','%Y年%m月%d日') 日期转换结果 FROM DUAL;
-- '2012/12/12'转日期
SELECT STR_TO_DATE('2012/12/12','%Y/%m/%d') 日期转换结果 FROM DUAL;
```



#### 二、组函数

##### 1.基本函数

> `max(字段名)`：获取这个字段中的最大值
>
> `min(字段名)`：获取这个字段的最小值
>
> `sum(字段名)`：某个字段的所有数据和
>
> `avg(字段名)`：该字段的平均值
>
> `count(字段名)`：统计该字段的个数(如果参数为*则表示总行数)

```sql
-- 查询最大工资
SELECT MAX(salary) FROM employees;
-- 查询最小工资
SELECT MIN(salary) FROM employees;
-- 查询工资和
SELECT SUM(salary) FROM employees;
-- 查询平均工资
SELECT AVG(salary) FROM employees
-- 查询employee_id的出现次数行数
SELECT count(employee_id) FROM employees;
-- 查询表的行数
SELECT count(*) from employees;
```

##### 2.分组

> 语法：select ... from...where...group by 字段名1，字段名2...order by...
>
> 作用：对于表中的数据进行分组
>
> 先根据字段名1进行分组，分组后的数据根据字段名2进行分组
>
> **注意：**
>
> ​	**1.只有在group by后面出现的字段推荐写在select后面，没有出现的字段不建议加在select后面**
>
> ​	**2.分组函数可以写在select后面**

```sqlœ
-- 查询工资最大值
SELECT MAX(salary) FROM employees;
-- 查询工资最小值
SELECT MIN(salary) FROM employees;
-- 查询工资和
SELECT SUM(salary) FROM employees;
-- 查询工资的平均值
SELECT AVG(salary) FROM employees
-- 查询员工id字段数
SELECT count(employee_id) FROM employees;
-- 查询所有行数
SELECT count(*) from employees;
-- 查询各岗位的平均工资  1.按照岗位进行分组	2.基于分组后的数据执行组函数AVG
SELECT job_id,avg(salary) from employees GROUP BY job_id;
-- 查询每个部门、每个岗位的最高工资 1.先根据部门分组2.根据岗位分组3.基于分组后的数据执行组函数max()
SELECT job_id,department_id,max(salary) from employees GROUP BY department_id,job_id;
-- 统计2004年各月份入职的人数
SELECT MONTH(hiredate),COUNT(*) from employees WHERE YEAR(hiredate) = 2004 GROUP BY MONTH(hiredate)
```

##### 3.having【重点】

> 作用：对分组后的数据进行条件过滤,符合条件的流下来
>
> 语法：select ... from...where...group by... having
>
> 
>
> 面试题：having和where的区别
>
> where														having
>
> 对分组前的数据进行过滤					对分组后的数据进行过滤
>
> 效率高												效率低
>
> 总结：
>
> ​	1.如果过滤条件能用where也能用having，优先使用where
>
> ​	2.过滤条件中使用分组后的数据，必须使用having

```sql
-- 查90，60，100号部门的平均工资
-- WHERE：筛查出90 60 100部门的员工
SELECT department_id,avg(salary)
FROM employees
WHERE department_id in(60,90,100)
GROUP BY department_id;

-- HAVING：对分组后的数据进行过滤
select department_id,avg(salary)
from employees
GROUP BY department_id
HAVING department_id in(60,90,100);
```



##### 4.查询总结

> 执行顺序：
>
> ​	`from`：确定原始表
>
> ​	`where`：基于原始表数据进行过滤，符合条件的留下
>
> ​	`group by`：符合where条件的将其分组
>
> ​	`select`：进行查询以及起别名
>
> ​	`having`：对分组后的数据进行过滤
>
> ​	`order by`：对产训后的数据进行最后的排序

##### 5.limit分页【重点】

> 作用：分页
>
> 语法：select...from...where...group by... having...order by...limit数据的其实下标，展示几条
>
> 注意：每条数据有下标，下标从0开始
>
> Limit 0,5：两个参数，第一个参数为起始下笔哦；第二个参数为数据条数。
>
> 去重：distinct

### 五、子查询

> 概念：一个完整的查询语句中嵌套另一个查询语句，内部的查询为自查询，外部的查询为主查询
>
> 1.子查询的结果是单个值（一行一列）
>
> 2.子查询的结果是(一行多列) in操作
>
> 3.子查询的结果是虚表

```sql
一行一列
-- 查询工资高于平均工资的员工信息
-- 1.平均工资是多少
SELECT AVG(salary) FROM employees;
-- 2.查询工资高于平均工资的员工信息
SELECT * FROM employees WHERE salary>6527.102804;
-- 合并
SELECT * FROM employees WHERE salary>(SELECT AVG(salary) FROM employees);
```

```sql
一行多列
-- 查询和King员工同部门的员工
SELECT department_id FROM employees WHERE last_name = 'King';
-- 查询部门号为80，90的员工
SELECT * FROM employees WHERE department_id IN(80,90);
-- 合并
SELECT * FROM employees WHERE department_id IN(SELECT department_id FROM employees WHERE last_name = 'King');
```

```sql
-- 子查询的结果是虚表
-- 查询工资对高的前五名
SELECT *
FROM
(SELECT * FROM employees ORDER BY salary desc) tb1
LIMIT 0,5;
```

### 六、表连接

> 表连接操作的三张表：
>
> ​	employees	107条数据
>
> ​	departments	27条数据
>
> ​	locations	23条数据
>
> 表链接的概念：查询的数据来源于多张表，需要将两张或者多张表合并成一张大表，称为表连接
>
> 表连接的类型：
>
> ​		内连接：`[inner] join`
>
> ​		外连接：
>
> ​				左外连接：`left [outer] join`
>
> ​				右外连接：`right [outer] join`
>
> ​		自连接：是一种特殊的表连接

#### 1.内连接

> 语法：`select...from 表名1 [inner] join 表名2 on 连接条件...where...group by...order by...`
>
> **特点：**
>
> ​	**1.查询结果：左表和右表基于连接条件，匹配成功的数据作为查询后的总行数**
>
> ​	**2.必须有连接条件**
>
> ​	**3.左表和右表没有顺序要求**
>
> **注意：如果存在字段名重复，必须使用表名.字段名**

```sql
-- 查询工号、姓、名、工资、所在部门编号、所在部门名称
SELECT e.employee_id,e.first_name,e.last_name,e.department_id,
d.department_name
FROM employees e
INNER JOIN departments d
ON e.department_id = d.department_id;
```

#### 2.外连接

> 左外连接：
>
> 语法：`select...from 表名1 left join 表名2 on 连接条件...where...group by...order by...`
>
> 左外连接的特点：
>
> ​		1.查询结果以左表为主，左表和右表配上数据匹配上的数据+左表没有匹配上的数据
>
> ​		2.必须有连接条件
>
> ​		3.左表和右表有顺序
>
> ​		4.没有匹配上的数据的时候右表的数据显示为null
>
> 右外连接的特点：
>
> ​		1.查询结果以右表为主，左表和右表配上数据匹配上的数据+右表没有匹配上的数据
>
> ​		2.必须有连接条件
>
> ​		3.左表和右表有顺序
>
> ​		4.没有匹配上的数据的时候左表的数据显示为null

#### 3.自连接

> 概念：是一种特殊的表连接
>
> 将一张表看成两张表

#### 4.sql92和sql99的差别

> 语法：`select ...from 表1 join 表2 on 连接条件 join 表3 on 连接条件 ...`

```sql
-- 案例：查询员工信息及部门名称
-- sql92
SELECT * FROM employees,departments -- 员工表的每一条数据连接所有的部门表的所有数据  条数：107x27 = 2889
WHERE employees.department_id=departments.department_id;-- 106条数据
-- sql99
SELECT * FROM employees e
LEFT JOIN departments d
ON e.department_id = d.department_id; -- 106条数据
```

### 七、SQL语句分类

> SQL：结构化查询语句
>
> ​	`DQL(data query language)`：查询语句。select【重点】
>
> ​	`DML(data manipulation language)`：数据操纵语言。insert/delete/update【重点】
>
> ​	`DDL(data defintion language)`：数据定义语言
>
> ​	`TCL(transaction control language)`：事物控制语言【重点】
>
> ​	`DCL(data control language)`：数据控制语言【控制数据库的访问权限等】

### 八、DDL建表语句

> create table 表名(
>
> ​	字段名1	数据类型	[默认值]	[约束1]	[约束2],
>
> ​	字段名2	数据类型,
>
> )

#### 1.数据类型

> 数字类型：
>
> ​		int类型：代表整数，占用4字节空间，最大值可以存储2147783647
>
> ​		double类型：代表小数占用8字节，使用凡事：double(5,2)第一个参数代表这个小数最多是5位，第二个代表小数部分占2位
>
> 字符串类型：
>
> ​		char(n)：固定长度字符串，n最大值是2000，代表分配字节数
>
> ​		varchar(n)：可变长度字符串类型，n最大值是4000，代表分配字节数
>
> ​		'abc'						char(5)						archer(5)
>
> ​										占空间						 不占空间
>
> ​										效率高						 效率低
>
> ​		如果当前列数据存储的是统一长度，比如手机号：char(11)	比如身份证号char(18)
>
> ​		小明		
>
> ​		张晓明
>
> ​		迪丽热巴	varchar(50)

#### 2.默认值

> 作用：标识该字段在填写任何内容时，系统分配的一个默认值
>
> 语法：default	值
>
> 注意：默认值的类型必须和字段的数据类型保持一致

#### 3.约束

##### (1)主键约束

> 作用：唯一标识表中的一行数据，没有业务含义，如工号、学号
>
> 特点：唯一、非空
>
> 语法：`primary key`
>
> 注意：开发中，每张表都有主键，只有一种特殊情况，只有关系表中没有主键

##### (2)唯一约束

> 作用：标识该字段的值，不允许重复。如身份证号、邮箱号
>
> 特点：唯一，但是可以为空
>
> 语法：`unique`

##### (3)非空约束

> 作用：标识该字段必须有内容，如学生姓名。
>
> 特点：非空、可以重复
>
> 语法：`not null`

##### (4)外键约束

> 作用：标识该字段的值不能随便输入，必须是另一张表主键或唯一键中存在的值
>
> 特点：可以重复、可以为null
>
> 语法：`foreign key 列名 references 表名`

##### 举例

> 表：student
>
> id(学号)	name(姓名)	address_id(外键)	连接address表的主键
>
> 1				zs							1
>
> 2				ls							 1
>
> 3				ww				 		  2
>
> 3				fj				 		     3		-错误：不能被使用，因为不在地址表的主键中
>
> ...
>
> 表address
>
> id		address			
>
> 1		麒麟公寓1栋
>
> 2		麒麟公寓2栋

#### 4.建表

> 创建班级信息表，班号-pk，班级名称-必填且不能重复

```sql
create table `clazz`(
	`claz_id` int primary key,
	`claz_name` varchar(4) not null unique
);
```

> 创建学生信息表，学号-pk,姓名-不能为空，年龄-默认18，邮箱-唯一，入学时间-不能为空，所在班级-fk

```sql
create table `student`(
	`stu_id` varchar primary key,
  `stu_name` varchar(30) not null,
  `age` int default 18,
  `email` varchar(50) unique,
  `hiredate` datetime not null,
  `clazz` varchar(5) foreign key
)
```

> 习惯：在创建表之前基本会执行删除表操作
>
> ```sql
> drop table if exists `student`
> ```

#### 5.工具建表

### 八、DML数据的增删改【重点】

#### 1.添加

> 语法：`insert into 表名(列名1，列名2，列名3) values(值1，值2，值3)`
>
> 作用：向表中添加一条数据
>
> 注意：
>
> ​	1.表名后的列名，必须是该表中存在的字段，没有先后顺序
>
> ​	2.values后面的值、顺序、类型、个数必须和表中字段完全一致
>
> ​	3.如果插入数据时，所有的字段都一次插入，则表明后的列名可以省略，但是值的顺序、类型、个数必须和表中字段一致
>
> ​	4.插入数据时，所有的非空字段必须有值
>
> ​	5.插入的字段时时间类型可以使用'2023-11-11'或'2023/11/11'

```sql
insert into clazz (claz_id, claz_name) values (1, '49班');
-- 简写
insert into clazz values (1, '49班');
-- 一次性插入多条
insert into clazz values (1, '49班'),(2, '37班');
```

#### 2.修改数据

> 语法：`update 表名 set 列名=新值,列名1=新值,列名2=新值 where 过滤条件;`
>
> 作用：根据where，符合条件的数据进行修改，如果没有指定条件，那么修改的是整张表

#### 3.删除数据

> 语法：delete from 表名 [where 条件]
>
> 作用：从表中删除符合where条件的数据，如果没有符合条件的，则删除整张表的数据

### 九、事务

### 十、锁

> 锁：在一个事物中insert/update/delete数据时，会获得该条数据的锁标记。直到事务结束才会释放锁标记，其他客户端才能获得锁标记进行操作

### 十一、事务的四大特性

> 1.原子性：十五中的多条sql是一个整体，要么成功提交，有一个失败就回滚
>
> 2.一致性：事务结束后 和 数据库中的数据状态保持一致。zs和zsxf两个账户转钱，转之前的总和，和转账之后的总和保持一致
>
> 3.隔离性：多用户并发，用户和用户的数据相互响应问题
>
> 4.持久性：提交后的事务是永久的

## 第二章 JDBC

### 一、引言

> `JDBC(Java Database Connectivity)`：java操作数据库技术
>
> 创建的java连接数据库技术，以下两种：
>
> ​		1.JDBC直接连接数据库				   --称为直连		   本次课程学习
>
> ​		2.JDBC通过连接池连接数据库 		--称为连接池		后续学习
>
> 内容：
>
> ​	1.接口：sun公司提供，jdk的java.sql包和java.sql包
>
> ​	2.实现类由各大厂商提供(到厂商的官网下载)，用来实际操作数据的，以jar包的形式体现

### 二、JDBC的jar包的引入方法

### 三、准备环境

> jdbc使用的一个准备操作：导入jar包

### 四、JDBC的6个步骤【重点】

```java
1.注册驱动
Class.forName("com.mysql.jdbc.Driver")
2.创建连接
String url = "jdbc:mysql://localhost:3306/BaiZhi?";
String username = "root";
String password = "Jin131212";
Connection connection = DriverManager.getConnection(url,username,password);
3.创建PreparedStatement
String sql = "select * from employees"
PreparedStatement preparedStatement = connection.prerpareStatement(sql);
4.执行sql
ResultSet resultSet = prepareStatement.executeQuery(); //查询时使用
prepareStatement.executeUpdate();//增删改时使用
5.处理查询结果 -- 针对查询操作
while(resutlSet.next()){
  ....
}
6.释放资源//最后用的先释放
resultSet.close();
preparedStatement.close();
connection.close();
```

### 五、JDBC常见的错误

> `java.lang.ClassNotFoundException: com.mysql.Driver`
>      说明: 包名.类名写错了
> ` java.lang.ClassNotFoundException: com.mysql.jdbc.Driver`
>      说明: jar包没有引入
>  `java.sql.SQLException: No suitable driver found for` `jdbc:mysql//localhost:3306/test2?characterEncoding=utf-8`
>      说明: 一定是路径问题、
> ` java.sql.SQLException: Access denied for user 'root'@'localhost' (using password: YES)`
>      说明: 检查用户名和密码
> ` jdbc4.MySQLSyntaxErrorException:`
> 	 说明: sql语句错误

### 六、查询操作

### 七、使用PreparedStatement代替Statement【重点】

```java
使用statement缺点:
	1.拼接sql容易出错
    2.存在安全隐患(sql注入问题)


String username = "小明";
//        String password2 = "123456";
String password2 = "1234567' or '1'='1";

//        1.注册驱动
Class.forName("com.mysql.jdbc.Driver");
//        2.创建连接
String url = "jdbc:mysql://localhost:3306/test2?characterEncoding=utf-8";
Connection conn = DriverManager.getConnection(url, "root", "root");
//        3.创建PreparedStatement
String sql = "select id,name,password from student where name=? and password=?";
PreparedStatement ps = conn.prepareStatement(sql);
//        4.执行sql
//        为?赋值
ps.setString(1,username);
ps.setString(2,password2);
ResultSet rs = ps.executeQuery(); //不要再传入sql语句
//        5.处理查询结果
while (rs.next()) {
    int id = rs.getInt("id");
    String name = rs.getString("name");
    String password = rs.getString("password");
    System.out.println(id + " " + name + " " + password);
}
//        6.释放资源
if (rs != null) rs.close();
if (ps != null) ps.close();
if (conn != null) conn.close();
```

#### 	7.1 PreparedStatement 和 statement区别【面试题】

```java
PreparedStatement    	statement
   安全性高(防止sql注入)  存在sql注入问题
   效率高				 效率低 
```

### 八、处理日期字段

> `SimpleDateFormat`：
>
> 1.格式化：日期类java.util.Date类型转化为文本字符串
>
> 2.解析：文本字符串转化为 日期java.util.Date类型
>
> 构造方法：
>
> `SimpleDateFormat(String pattern)`：指定日期格式
>
> y年		M月份		d天		H小时(0-23)		m分钟		s秒
>
> 解析功能：文本转日期
>
> Date parse(String source)：从给定字符串开始解析文本，以生成一个日期
>
> `String time = "2022年08-20";`
>
> `SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM-dd");`
>
> `Date date = sdf.parse(time);`

### 九.插入一条数据带有日期类型

```java
String name2 = "小紫";
String password2 = "123";
String hiredate2 = "2022-11-11";
//        1.注册驱动
Class.forName("com.mysql.jdbc.Driver");
//        2.创建连接
String url = "jdbc:mysql://localhost:3306/test2?characterEncoding=utf-8";
Connection conn = DriverManager.getConnection(url, "root", "root");
//        3.创建ps
String sql = "insert into student(name,password,hiredate) values(?,?,?)";
PreparedStatement ps = conn.prepareStatement(sql);
//        4.执行sql
//        ?赋值
ps.setString(1,name2);
ps.setString(2,password2);
//        第二个参数类型:  java.sql.Date
//        String -- > java.sql.Date
//        1.String -- >java.util.Date
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
Date date = sdf.parse(hiredate2);
//        2.java.util.Date 转换为毫秒值
long time = date.getTime();
//        2.转java.sql.Date 构造方法: Date(long date)
java.sql.Date sqlDate = new java.sql.Date(time);
ps.setDate(3,sqlDate);
ps.execute();

//        5.处理查询结果
//        6.释放资源
if( ps != null ) ps.close();
if( conn != null) conn.close();
```

### 十、JDBC的6个问题

> 1.JDBC的6个步骤的代码冗余
>
> 2.代码无复用
>
> 3.

#### 一、第一步【解决代码冗余】

> 封装成工具类

#### 二、第二步【提高代码维护姓】

> 配置mysql jdbc配置文件

```properties
#创建db.properties
driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/BaiZhi?characterEncoding=utf-8
username=root
password=Jin131212
```

```java
		//为了提高作用范围
    //为了能够在静态代码块中访问如：getConnection
    private static final Properties properties = new Properties();
    static {
        InputStream inputStream = null;
        try {
                inputStream = JDBCUtil.class.getResourceAsStream("/db.properties");
                properties.load(inputStream);
            } catch (Exception e) {
                e.printStackTrace();
            }finally {
                if (inputStream != null) {
                    try {
                        inputStream.close();
                    } catch (Exception e) {
                        e.printStackTrace();
                    }finally {
                        inputStream = null;
                    }
                }
        }
        }
```

```java
				//获取连接
        public static Connection getConnection(){
            Connection connection = null;
            try {
                //注册jdbc驱动
                Class.forName(properties.getProperty("driver"));
                String url = properties.getProperty("url");
                String username = properties.getProperty("username");
                String password = properties.getProperty("password");
                connection = DriverManager.getConnection(url,username,password);
            } catch (Exception throwables) {
                throwables.printStackTrace();
            }
            return connection;
        }
```

### 十一、ORM对象关系映射

> Object Relational Mapping：对象关系映射
>
> 表中的一行数据		对应		Java的一个对象
>
>
> 的类的定义要求：根据当前表结构定义
>
> 1.类名同表名
>
> ​		表名		类名
>
> ​		user		User
>
> ​		t_user	 User
>
> ​		student   Student
>
> 2.属性与列名相同，并且提供属性的私有化，提供get、set方法

|  id  | name | Score |
| :--: | :--: | :---: |
|  1   | 小明 |  80   |
|  2   | 小红 |  100  |

```java
public class student{
  private Integer id;
  private String name;
  private Double score;
  //get和set
  //toString
}
```



```java
public List<Student> selectAll(){
        Connection connection = JDBCUtil.getConnection();
        String sql = "select id,name,age,sid from student group by sid";
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;
        List<Student> list = new ArrayList<>();
        try {
            preparedStatement = connection.prepareStatement(sql);
            resultSet = preparedStatement.executeQuery();
            while (resultSet.next()){
                Student student = new Student();
                student.setId(resultSet.getInt("id"));
                student.setName(resultSet.getString("name"));
                student.setAge(resultSet.getInt("age"));
                student.setSid(resultSet.getString("sid"));
                list.add(student);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        JDBCUtil.closeAll(preparedStatement,connection,resultSet);
        return list;
    }
```

### 十二、功能整合

> 整合的原则：一个表所相关的所有操作
>
> 命名原则：表名+Dao  student 的dao层类：studentDao
>
> 包的命名：com.baizhi.dao
>
> 类中的方法：所有的方法只能针对数据库的增删改查，其他代码一改不允许出现
>
> ​		删除：`public void deleteById(int id);`
>
> ​		添加：`public void insertStudent(Student stu);`
>
> ​		修改：`public void updateStudent(Student stu);`
>
> ​		查询：
>
> ​				根据id查一个：`public Student queryById(int id)`
>
> ​				查所有：`public List<Student> queryAll()`
>
> ​				根据名字模糊查：`public List<Student> queryLikeByName(String name)`
>
> ​				

### 十三、Service层

> 调用dao的一个或多个方法实现自己所想要实现的业务
>
> 其中涉及到事务的控制

## 第三章 HTML

### 一、引言

> HTML(HyperText Marking Lanaguage)：简称HTML，超文本标记语言，是一种创建网页的标准语言，运行在浏览器，由浏览器节气

### 二、编写网页

> 1.创建一个文本文件，文件后缀：HTML
>
> 2.在其中进行文本编辑
>
> 3.使用浏览器运行html文件

### 三、开发工具

> idea
>
> HBuilderX下载
>
> VScode

### 四、基本语法

#### 1.标签

> 一个网页中的所有内容(图片、按钮、输入框等)，都是由标签进行描述

#### 2.语法

> <标签名>标签的内容</标签名>

#### 4.案例

```html
<p>这是一个段落</p>
换行
<br/>
```

### 五、基本架构

```html
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
  </body>
</html>
```

说明：

- `html`：是网页的根元素
- `head`：包含了文档的描述信息，不会显示在页面中<meta charset="utf-8">定义网页编码格式，表示浏览器解析该网页使用这个编码格式
- `title`：网页的标题
- `body`：包含了页面内容，后续所有要显示在页面中的标签，都放在body中。

### 六、常见标签

#### 1.标题

> `h1`：表示一级标签
>
> `h2`：表示二级标签
>
> ...
>
> `h6`：表示六级标签

```html
<html>
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
  </head>
  <body>
    <h1>一级标题</h1>
    <h2>二级标题</h2>
    <h3>三级标题</h3>
    <h4>四级标题</h4>
    <h5>五级标题</h5>
    <h6>六级标题</h6>
  </body>
</html>
```

#### 2.段落

> `<p>`段落中的内容`</p>`

```html
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <p>要想健康又长寿，</p>
    <p>抽烟喝酒吃肥肉，</p>
    <p>晚睡晚起不锻炼，</p>
    <p>多与异性交朋友，</p>
</body>
</html>
```

#### 3.特殊字符

| 字符 | 转义字符 |
| :--: | :------: |
|  <   |  `&lt;`  |
|  >   |  `&gt;`  |

#### 4.换行符

> `<br/>`：换行效果

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1>一级标题</h1>
    <h2>二级标题</h2>
    <h3>三级标题</h3>
    <h4>四级标题</h4>
    <h5>五级标题</h5>
    <h6>六级标题</h6>

    <p>要想健康又长寿，</p>
    <p>抽烟喝酒吃肥肉，</p>
    <p>晚睡晚起不锻炼，</p>
    <p>多与异性交朋友，</p>
    这是第一行,<br/>这是第二行
</body>
</html>
```

#### 5.图片

> 作用：在网页中显示图片
>
> 语法：`<img src=""/>`
>
> 属性：
>
> - `src`：必须要有，代表文件的路径(相对路径、绝对路径、网络路径)
> - `alt`：当图片不显示时所展示的文本
> - `title`：当鼠标悬停到图片上时所显示的内容
> - `width`：宽度(单位px)
> - `height`：高度(单位px)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <img src="./截屏2023-06-08 09.03.05 (2).png"/ width="300" height="300" alt="当前图片有问题">
</body>
</html>
```

#### 6.超链接

> 作用：跳转到另一张页面或发送请求
>
> 语法：`<a href="跳转到另一个资源的连接"></a>`
>
> 属性：
>
> - `href`：表示跳转的路径
> - `target`：表示打开的方式
>   - `_self`：当前窗口打开
>   - `_blank`：新窗口打开

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <a href="http://www.google.com">跳转到谷歌</a>
</body>
</html>
```

#### 7.span行级标签

> 作用：本身是没有任何样式，用于对一行中的内容设置样式
>
> 例如：`<span 设置该段文本的样式>用户名：</span>`

#### 8.div块级元素

> 作用：设置一个块区域的样式，自占一行
>
> 例如：`<div>用户名：</div>`
>
> 注意：div和span的区别在于span后的文本不会换行，但是div后的文本会换行

#### 9.表格

> 基本表格结构：
>
> `<table>`
>
> ​	`<tr>`
>
> ​			`<td></td>`
>
> ​	`</tr>`
>
> `</table>`
>
> 1.table：
>
> - `border`：边框
> - `width`：宽度
> - `align`：对齐方式
> - `bgcolor`：背景色
> - `cellspacing`：单元格间距(一般设置为0)
>
> 2.tr代表行：
>
> - align：整行内部的文字水平对齐方式，可选：center/left/right
>
> 3.th表示标题单元格，td表示水平内容
>
> - rowspan：合并行
> - colspan：合并列

```html
<table border="1" width="50%" align="center" bgcolor="purple" cellspacing="0">
        <tr>
            <th>姓名</th>
            <th>年龄</th>
            <th>性别</th>
        </tr>
        <tr>
            <td>小明</td>
            <td>18</td>
            <td>男</td>
        </tr>
        <tr>
            <td>小红</td>
            <td>19</td>
            <td>女</td>
        </tr>
    </table>
```

#### 10.表单

> 语法：
>
> `<form>`
>
> ​		表单中的元素
>
> `</form>`
>
> 属性详解：
>
> - name：服务器获取数据的标记

```html
<form action="">
        <input type="text" placeholder="请输入用户名" disabled="disabled" readonly="readonly">
        <input type="submit" value="提交">
    </form>
```

密码框元素

> 语法：
>
> ​	`<input type="password" name="" maxlength="5">  </input>`

单选框

> 语法`<input type="radio" name="sex" checked="checked">男 <input type="radio" name="女">`
>
> 

复选框

> 同一组复选框的名字得一致

```html
爱好：<input type="checkbox" name="hobby">抽烟
        <input type="checkbox" name="hobby">喝酒
        <input type="checkbox" name="hobby">吃肥肉<br>
        <input type="submit" value="提交">
```

下拉框

> 说明：
>
> - select标签表示一个下拉框
>
>   name：当前元素的数据名字。以后用来数据发送和服务器获取的标记
>
> - option标签，表示一个选项
>
>   - 标签体：代表展示给用户的每一个选项
>   - 
>
>   

```html
<select name="ss" id="">
            <option value="1">篮球</option>
            <option value="2">足球</option>
            <option value="3">网球</option>
        </select>
```

文本域

> 语法格式：`<textarea>文本域的内容</textarea>`
>
> 属性：
>
> - row：列数(一行可以写多少个字)

按钮

> 语法：`<button></button>`
>
> 属性：
>
> - submit：提交
> - reset：重置
> - number：输入数字
> - date：输入日期

Ifrme显示

> 语法：
>
> ​	`<iframesrc src="test1.html" widtch="100%" height="10px"></iframesrc>`
>
> 属性：
>
> - src：被引用的页面的路径
> - name：iframe的名字，通常作为超链接标签跳转的target属性
> - scrolling：是否显示滚动条，no就是不显示
> - frameborder：iframe的边框宽度

跳转

1.超链接

```html
<a href="资源路径" target="iframe的name值"></a>
```

2.iframe框架

```html
<iframe name="iframe的name"></iframe>
```

## 第四章 CSS

### 一、入门

> css(cascading Style Sheets)：层叠样式表
>
> 作用：美化页面技术

| 属性名           | 作用     |
| ---------------- | -------- |
| color            | 字体颜色 |
| width            | 宽       |
| height           | 高       |
| Background-color | 背景颜色 |
| font-size        | 字体颜色 |



### 二、行内样式

> 作用：应用于网页中的一个元素添加样式。
>
> 语法：<html标签 style="font-size:100px;background-color:blue;"></html标签>

### 三、内嵌样式

> 作用：作用与页面中的多个标签
>
> 语法：`<head>`
>
> ​			`<style type="text/css">`
>
> ​			`选择器名称{
> ​			  属性名：属性值;
>   ​			  属性名：属性值;
> ​		}`
>
>
> ​		`</style>`
>
> ​		`</head>`

#### 1.标签选择器

> 作用：网页中所有相同的标签名可以设置同一个样式
>
> 语法：标签名：{
>
> ​				属性：样式;
>
> ​			}

```
<style type="text/css">
        h1{
            font-size: 100px;
            background-color: #CCFFFF;
            width: 200px;
        }
    </style>
    <h1>百知</h1>
    <h1>百度</h1>
```

#### 2.类选择器

> 作用：网页中不同标签同一个样式
>
> 语法：
>
> ​	.名称：{
>
> ​				属性：样式;
>
> ​			}
>
> 当样式重复时,它只会选择最下面的样式

```
<style type="text/css">
        .abc{
            background-color: aquamarine;
        }
        .bb{
        		background-color: blue;
        }
</style>
<span class="abc">你好</span>
<span class="abc">我好</span>
<span class="abc">大家好</span>
```

#### 3.id选择器

> 作用：网页中不同标签同一个样式
>
> 语法：
>
> ​	.名称：{
>
> ​				属性：样式;
>
> ​			}
>
> 注意：在html中，id属性通常不会用来定义样式

```html
<style type="text/css">
        /* 标签选择器 */
        h1 {
            font-size: 100px;
            background-color: #CCFFFF;
            width: 200px;
        }

        /* class选择器 */
        .abc {
            background-color: aquamarine;
        }

        /* id选择器 */
        #aa {
            background-color: saddlebrown;
        }
</style>
<span id="aa">你好</span>
<span id="abc">我好</span>
<span id="abc">大家好</span>
```

### 四、伪类选择器

> 作用：用于定义元素的特殊状态
>
> 例如：鼠标在超链接上悬停的状态

### 五、外部样式

> 为了多个页面复用css样式，将所有的css写入一个xxx.css文件中，然后在html中使用link标签引入到页面当中

外部css文件

```css
h1 {
            font-size: 100px;
            background-color: #CCFFFF;
            width: 200px;
        }

        /* class选择器 */
        .abc {
            background-color: aquamarine;
        }
```

html引入

### 六、盒子模型

> 将div想象成一个盒子，可以设置盒子的内边距和外边距
>
> 外边距：margin(左外边距优先)
>
> 内边距：padding

```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        div{
            background-color: brown;
            width: 200px;
            height: 200px;
            /* padding-left: 50px;
            padding-top: 50px;
            padding-right: 50px;
            padding-bottom: 50px; 
            padding: 50px;*/
            /* margin-top: 100px;
            margin-left: 100px;
            margin-right: 100px;
            margin-bottom: 100px; */
            margin: 100px;
        }
    </style>
</head>
<body>
    <div>这是一个盒子</div>
</body>
</html>
```

## 第五章 BootStrap5

### 一、入门

> 概念：BootStrap是一个前端的框架，封装了大量css样式，可以直接使用。极大的简化了前端页面构建速度

### 二、相关资料



### 三、Bootstrap实现一个按钮

```html
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../bootstrap-5.3.0-alpha1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../font-awesome-4.7.0/css/font-awesome.css">

</head>
<body>
    <i class="fa fa-shopping-cart"></i>
    <button class="btn btn-success">加入购物车</button>
    <button class="btn btn-success"><i class="fa fa-shopping-cart"></i>加入购物车</button>
</body>
</html>
```

### 四、常见组建

|      样式      |                  含义                  |
| :------------: | :------------------------------------: |
| class="text-*" | 通过在文字上设置text-*来设置文字的颜色 |
|  class="bg-*"  |       通过bg-*设置文本的背景颜色       |

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../bootstrap-5.3.0-alpha1-dist/css/bootstrap.css"/>
    <link rel="stylesheet" href="../font-awesome-4.7.0/css/font-awesome.css">
</head>
<body>
    <span class="text-muted">柔和的文本</span><br>
    <span class="text-primary">重要的文本</span><br>
    <span class="text-success">成功的文本</span><br>
    <span class="text-info">提示文本</span><br>
    <span class="text-warning">警告文本</span><br>
    <span class="text-danger">危险文本</span><br>
    <span class="text-secondary">我是文本</span><br>
    <span class="text-dark">黑色文本</span><br>
    <span class="text-body">我是文本</span><br>
    <span class="text-light bg-black">浅灰文本</span><br>
    <span class="text-white bg-secondary">白色文本</span>
</body>
</html>
```

### 五、徽章

| 样式         | 含义               |
| ------------ | ------------------ |
| badge        | 主要用于突出显示   |
| bg-*         | 设置背景颜色       |
| rounded-pill | 设置形状为药丸形状 |

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../bootstrap-5.3.0-alpha1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../font-awesome-4.7.0/css/font-awesome.css">
</head>
<body>
    <span class="badge bg-primary">可用</span>
    <span class="badge bg-danger rounded-pill">冻结</span>
</body>
</html>
```

### 六、按钮

|      样式      |                     含义                     |
| :------------: | :------------------------------------------: |
|      btn       | 作用于<a>、<button>、<input>变为bs的一个按钮 |
|     btn-*      |       设置按钮为实心按钮，并指定背景色       |
|  btn-outlin-*  |                设置为空心按钮                |
| btn-lg\|btn-sm |     设置按钮大小，lg为大按钮，sm为小按钮     |

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../bootstrap-5.3.0-alpha1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../font-awesome-4.7.0/css/font-awesome.css">
</head>
<body>
    <button class="btn">基本按钮</button>
    <a href="" class="btn">这是超链接</a>
    <button type="button" class="btn btn-primary">主要按钮</button>
    <button type="button" class="btn btn-success">成功按钮</button>
    <button type="button" class="btn btn-outline-primary">我是空心按钮</button>
    <button type="button" class="btn btn-primary btn-lg">发是超链接</button>
    <button type="button" class="btn btn-primary btn-sm">发是超链接</button>

</body>
</html>
```

### 七、容器

| 样式                    | 含义                                             |
| ----------------------- | ------------------------------------------------ |
| class="container"       | 固定宽度，屏幕两侧会有固定留白，用于前台页面布局 |
| class="container-fluid" | 100%宽度，两侧不留白的容器，常用于后台管理系统   |



```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../bootstrap-5.3.0-alpha1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../font-awesome-4.7.0/css/font-awesome.css">
</head>
<body>
    <div class="container bg-primary vh-100">我是左右留白</div>
    <div class="bg-success container-fluid vh-100">100%宽度，不留白</div>
</body>
</html>
```

### 八、尺寸

- 样式：

|   样式   |                    含义                     |
| :------: | :-----------------------------------------: |
|  vh-100  | 高度占据整个屏幕，只能用在最外部的div标签上 |
|  h-100   |            占据父div高度的的100%            |
|   h-25   |            占据父div高度的的25%             |
|   h-50   |            占据父div高度的的50%             |
|   h-75   |            占据父div高度的的75%             |
|  col-1   |           占据父div宽度的12分之1            |
|  col-3   |           占据父div宽度的12分之3            |
|  Col-10  |            占据父div宽度的6分之5            |
| rounded  |                设置div为圆角                |
|  border  |                  启用边框                   |
| border-* |             设置边框宽度*为数字             |
| border-* |               设置边框颜色为*               |



- 代码：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../bootstrap-5.3.0-alpha1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../font-awesome-4.7.0/css/font-awesome.css">
</head>
<body>
    <div class="container bg-success vh-100">
    <div class="container bg-info h-25"></div>
    <div class="container bg-danger h-50"></div>
    </div>
</body>
</html>

```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../bootstrap-5.3.0-alpha1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../font-awesome-4.7.0/css/font-awesome.css">
</head>
<body>
    <div class="container bg-primary vh-100">
        <div class="bg-success col-1">col1</div>
        <div class="bg-success col-2">col2</div>
        <div class="bg-success col-6">col6</div>
        <div class="bg-success col-10">col6</div>
        <div class="bg-success col-12">col12</div>
        <div class="container border border-5 border-danger h-25"></div>
    </div>
</body>
</html>
```

### 九、布局flex

> flex可以决定主轴方向，就是默认子元素排列的方向是从垂直方向还是交叉方向

|        样式         |                             说明                             |
| :-----------------: | :----------------------------------------------------------: |
|       d-flex        |            开启flex布局，表名内部元素使用flex布局            |
|      flex-row       | 子元素横向排列，从左到右，且这个方向设置为主轴，垂直方向是交叉轴，默认的主轴方向 |
|  flex-row-reverse   |        子元素横向排列，从右到左，且这个方向设置为主轴        |
|     flex-column     |        子元素纵向排列，从上到下，且这个方向设置为主轴        |
| flex-column-reverse |        子元素纵向排列，从下到上，且这个方向设置为主轴        |
|  justify-content-*  | 控制子元素在主轴上的排列方式，，*允许为start、end、between、around |
|    align-item-*     | 控制子元素在交叉轴上的排列方式，*允许的值有start、end、center |

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../bootstrap-5.3.0-alpha1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../font-awesome-4.7.0/css/font-awesome.css">
</head>
<body>
    <div class="container bg-info vh-100">
        <div class="container bg-primary h-25 d-flex">
        <div class="container bg-danger-subtle h-20 col-2">1</div>
        <div class="container bg-danger-subtle">2</div>
        <div class="container bg-danger-subtle">3</div>
        <div class="container bg-danger-subtle">4</div>
    </div>
    <br>
    <br>
    <div class="container bg-success h-25 d-flex justify-content-between">
        <div class="container bg-danger-subtle">1</div>
        <div class="container bg-danger-subtle">2</div>
        <div class="container bg-danger-subtle">3</div>
        <div class="container bg-danger-subtle">4</div>
    </div>
    <br>
    <br>
    <div class="container bg-success h-25 d-flex justify-content-between">
        <div class="container bg-danger-subtle col-1 h-20">1</div>
        <div class="container bg-danger-subtle col-1 h-20">2</div>
        <div class="container bg-danger-subtle col-1 h-20">3</div>
        <div class="container bg-danger-subtle col-1 h-20">4</div>
    </div>
    <br>
    <br>
    <div class="container bg-success h-25 d-flex justify-content-around flex-column align-items-center">
        <div class="bg-danger-subtle col-1 h-20">1</div>
        <div class="bg-danger-subtle col-1 h-20">2</div>
        <div class="bg-danger-subtle col-1 h-20">3</div>
        <div class="bg-danger-subtle col-1 h-20">4</div>
    </div>
    </div>
</body>
</html>
```

### 十、卡片card

- 样式

| 样式        | 含义                                           |
| ----------- | ---------------------------------------------- |
| card        | 父div添加card表名当前整个div是一个card面板卡片 |
| card-head   | 子div添加card-header，代表整个div的头部        |
| card-body   | 子div添加card-header，代表整个div的身体        |
| card-footer | 子div添加card-header，代表整个div的底部        |

- 代码

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="../font-awesome-4.7.0/css/font-awesome.css">
</head>
<body>
    <div class="card vh-100">
        <div class="card-header">头</div>
        <div class="card-body">身体</div>
        <div class="card-footer">底部</div>
    </div>
</body>
</html>
```

### 十一、导航栏

| 样式            | 含义                                                         |
| --------------- | ------------------------------------------------------------ |
| navbar          | 设置为导航栏                                                 |
| Navbar-expand-* | 设置导航栏的尺寸，navbar-expand-xx(xx\|\|x\| lg\| md\|sm)创建响应式导航栏 |
| bg-*            | 设置背景颜色                                                 |
| navbar-dark     | 设置文字颜色                                                 |
| navbar-brand    | 设置导航栏的品牌logo，且为超链接                             |
| navbar-nav      | 设置导航链接，用在li标签上                                   |
| navbar-item     | 导航栏中的每一个元素                                         |
| Nav-link        | 设置导航中每一个连接，用在a标签上                            |

### 十二、表单

|               样式               |                           含义                            |
| :------------------------------: | :-------------------------------------------------------: |
|           form-control           |              用在input标签上，让标签有bs效果              |
|           input-group            | 用在input的父标签div上，开启组合。span和input进行组合显示 |
|         input-group-text         |                  配合input-group的输入框                  |
| Form-control-lg\|form-control-sm |                    大输入框和小输入框                     |
|         form-check-input         |                 作用在radio和checkbox当中                 |
|           form-switch            |                   开关，用在checkbox上                    |
|                                  |                                                           |
|                                  |                                                           |
|                                  |                                                           |

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../bootstrap-5.3.0-alpha1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../font-awesome-4.7.0/css/font-awesome.css">
</head>

<body>
    <div class="container d-flex flex-column justify-content-center align-items-center vh-100">
        <div class="card col-4 h-20">
            <div class="card-head text-center bg-primary-subtle">
                <h4>注册</h4>
            </div>
            <div class="card-body">
                <div class="input-group">
                    <i class="fa fa-user input-group-text"></i>
                    <input type="text" class="form-control">
                </div>
                <div class="input-group mt-3">
                    <i class="fa fa-lock input-group-text"></i>
                    <input type="password" class="form-control">
                </div>
                <div class="form-check-inline mt-3">
                    <input type="radio" class="form-check-input">男
                    <input type="radio" class="form-check-input">女
                </div>
                <div class="form-check-inline mt-3">
                    <input type="checkbox" class="form-check-input">抽烟
                    <input type="checkbox" class="form-check-input">喝酒
                    <input type="checkbox" class="form-check-input">烫头
                </div>
                <div class="form-switch mt-3">
                    <input type="checkbox" class="form-check-input">冻结
                </div>
                <textarea name="" id="" cols="30" rows="10" class="form-control mt-3" placeholder="请输入自我介绍"></textarea>
            </div>
        </div>
    </div>
</body>

</html>
```



### 十三、表格

| 样式               | 含义                            |
| ------------------ | ------------------------------- |
| table              | 启动bs表格效果，用在table标签上 |
| table-bordered     | 表格添加边框，用在table标签上   |
| table-hover        | 为表格的每一行上色              |
| table-*            | 添加背景色，用在tr标签上        |
| table-lg\|table-sm | 调整表格的大小，用在table标签上 |

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../bootstrap-5.3.0-alpha1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../font-awesome-4.7.0/css/font-awesome.css">
</head>
<body>
    <table class="table table-bordered table-hover">
        <tr>
            <th>用户名</th>
            <th>性别</th>
            <th>年龄</th>
            <th>工资</th>
        </tr>
        <tr>
            <td>如来</td>
            <td>男</td>
            <td>1000</td>
            <td>2000</td>
        </tr>
        <tr>
            <td>女娲</td>
            <td>女</td>
            <td>2000</td>
            <td>3000</td>
        </tr>
    </table>
</body>
</html>
```



### 十四、无序列表

|             样式             |                      含义                      |
| :--------------------------: | :--------------------------------------------: |
|          pagination          |             开启分页，用在ul标签上             |
| pagination-sm\|pagination-lg |          设置分页的大小，用在ul标签上          |
|    Justify-content-center    | 分页在父容器中居中显示，父容器不能使用flex布局 |
|          page-item           |              分页连接项，用在li上              |
|            active            |                   活跃当前页                   |

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="../bootstrap-5.3.0-alpha1-dist/css/bootstrap.css">
    <link rel="stylesheet" href="../font-awesome-4.7.0/css/font-awesome.css">
</head>
<body>
    <ul class="pagination">
        <li class="page-item"><a href="" class="page-link">上一页</a></li>
        <li class="page-item"><a href="" class="page-link">1</a></li>
        <li class="page-item"><a href="" class="page-link">2</a></li>
        <li class="page-item"><a href="" class="page-link active">3</a></li>
        <li class="page-item"><a href="" class="page-link">下一页</a></li>
    </ul>
</body>
</html>
```

## 第六章 JavaScript

### 一、引言

> JavaScript:简称JS。网景公司，主要用来增加页面的交互性和制作网页的动态效果，比如轮播图和表单的验证，是前端不可缺少的一门语言。运行在浏览器中。

#### 1.1特点

```js
1.js是弱类型语言，所有的数据都可以存储在const(常量)和let(变量)类型的变量中
		java：int a = 10		String s = "abc"		double d = 1.1
		js:	let a = 10		let a = "abc"		let a = 1.1
2.严格区分大小写
3.存在浏览器差异
4.js是一门解释行语言，每次运行从头到尾注行解释执行，运行效率低
5.很多组建的语言都与java一致，例如：if、for、while，但它不是hava
```

#### 1.2作用

```js
1.表单验证
2.动态特效
```

#### 1.3语法

```html
<head>
  <script type="text/javaScript">
		//js代码
	</script>
</head>
```

### 二、第一个javascript程序

```html
<script type="text/javascript">
    // js中使用注释是 //
    // 向html网页输出 helloworld
    document.write("<h1>helloworld</h1>")
</script>
```

### 三. javaScript控制台数据

- 作用: 用于调试

- 语法:

  ```js
  console.log("输入的内容")
  ```

- 例如:

  ```js
  console.log("helloworld")
  ```

- 在浏览器中按 f12 进入开发者模式，点击console 窗口

### 四.变量

- 作用: 存储数据

- 命名规范: 由字母、数字、_、$组成，数字不能开头

- 语法:

  ```js
  javaScript变量没有明确的类型
  	let: 表示变量
      const: 表示常量
  ```

- 例如：

  ```js
  let a = 10;
  let b = 1.1;
  let c = "hello";
  const d = 对象类型;
  ```

### 五.数据类型

- 通过 typeof 获取变量中存储的数据类型

- 语法 typeof 值或变量

- 例如:

  ```js
  <script type="text/javascript">
      // 1. number 数字类型
      console.log(typeof 10)
      console.log(typeof 1.1)
  
      // 2.string 字符串类型, ""和''没有区别都代表字符串
      console.log(typeof "abc")
      console.log(typeof 'a')
  
      // 3.boolean 类型
      console.log(typeof true)
  
      // 4.undefined 类型。这种类型是变量未赋值
      let a;
      console.log(typeof a)
  
      // 5.object 对象类型
      let b = null;
      console.log(typeof b)
  </script>
  ```

- 通过上面演示我们得知js中的数据类型有

  ```java
  原始数据类型:
  	number boolean string  undefined
  引用类型:
  	array 日期
  ```


### 六.运算符【重点】

#### 	6.1 赋值运算符 :=   +=    -=  *=   /=     %=

#### 	6.2 数学运算符: +   -   *   /    %

#### 		  6.3 比较运算符: >   >=    <    <=     !=      ==     ===

​					==和===区别:

​						==用于比较数值是否相同

​                        ===比较数值+类型

​					例如:

```js
let a = "1.5";
let b = 1.5;

console.log(a == b)  //true
console.log(a === b) //false
```

#### 		6.4 逻辑运算符: &&   ||  !

### 七. 模板字符串

- 概念: 解决了字符串拼接的烦恼。

- 语法:

  ```js
  `字符串内容`
  ```


#### 7.1 模板字符串可以换行

```java
// 普通字符串拼接
console.log("我是一个"+
"好学生") //传统字符串回车不能换行

console.log("我是一个\n好学生")

// 模板字符串
console.log(`我是一个
好学生`) //模板字符串回车就可以换行
```



#### 	7.2 模板字符串中插入变量

```js
let name = "小明"
let age = 18
console.log("我是:"+name+",年龄:"+age)
console.log(`我是:${name},年龄:${age}`)
```

### 八. 条件分支与循环结构

#### 	8.1 条件分支

- 基础if语法:

  ```js
  if(布尔类型表达式){
      
  }
  ```

- if...else..语法:

  ```js
  if(布尔类型表达式){
      
  }else{
      
  }
  ```

- if...else if...语法:

  ```js
  if(布尔类型表达式){
      
  }else if(布尔类型表达式){
      
  }else if(布尔类型表达式){
      
  }else{
      
  }
  ```

#### 	8.2 循环结构

```js
while循环语法:
while(布尔类型表达式){
    
}

do..while循环语法:
do{
    
}while(布尔类型表达式)
    
for循环语法:
for(循环变量;设置循环条件;控制步长){
    
}
```

### 九.函数【重点】

- 作用: 具有特点功能的一段代码，在js中函数也是一种数据类型。该类型是function。

#### 9.1 基础函数

- 函数的定义语法

  ```js
  // 定义函数
  function 函数名(参数名1,参数名2...){
      return 返回值;
  }
  
  // 调用
  函数名(实参1,实参2...);
  ```

- 例如:

  ```js
  function sum(a,b){
      return a+b
  }
  
  let result = sum(1,2)
  console.log(result)
  ```

#### 9.2 可边长参数

- 函数可以接收任意数量的参数，使用 arguments 获取所有参数，arguments是数组类型的数据需要遍历或使用下标获取

- 例如:

  ```js
  function sum(){
      //使用 arguments 获取每一个实参
      let result = 0;
      for(let i = 0; i<arguments.length; i++){
          result += arguments[i]
      }
      console.log(result)
  }
  sum(1,2,3,4)
  sum(1,2,3,4,5,6,7,8)
  ```

#### 9.3 匿名函数

- 作用: 在javaScript可以为变量赋值函数类型。

- 语法:

  ```js
  //函数本身没有名称，为了调用该函数存放到变量中
  let 变量名 = function(参数名1,参数名2){
      
  }
  //调用函数
  变量名(实参1,实参2)
  ```

#### 9.4 箭头函数

- 作用: 箭头函数相当于匿名函数，并简化了函数定义。

- 语法:

  ```js
  let 变量名 = (参数)=>{
      函数体
  }
  
  例如:
  	//箭头函数
  	let fn = (name)=>{
          return `hello ${name}`;
      }
      
      //等同于
      let fn = function(name){
          return `hello ${name}`;
      }
  ```

- 特点:

  - 箭头函数在语法上比普通函数简洁很多。箭头函数就是采用=>来定义函数，省去关键字function
  - 函数的参数放在=>前面的括号中，函数体跟在=>后面

- 箭头函数的参数

  - 如果箭头函数没有参数，写空括号

    ```java
    let fn = ()=>{
        console.log("hello")
    }
    fn()
    ```

  - 如果箭头函数有一个参数，可以省略()

    ```js
    let fn = name=>{
        console.log(name)
    }
    ```

  - 如果箭头函数有多个参数，将参数依次用逗号分隔，写在()中

    ```java
    (val1,val2,val3)=>{
    
    }
    ```

- 箭头函数的函数体

  - 如果箭头函数的函数体只有一句执行代码，简单返回某个变量或返回一个简单的js表达式可以省去函数的花括号和return

  - 例如:

    ```js
    //返回某个变量
    let f = val=>val
    //等同于
    let f = function(val){return val}
    
    //返回一个简单js表达式
    let f = (val1,val2)=>val1+val2
    //等同于
    let f = function(val1,val2){
        return val1+val2
    }
    ```

### 十.对象

- 在 javaScript 语言中，没有类的概念，在构建对象后可以直接为属性赋值，javaScript会自动为对象设置该属性。

#### 10.1 创建对象

```java
语法:
const 对象名 = {
    属性1:属性值,
    属性2:属性值,
    ...
    属性3:function(参数1,参数2...){
        函数体
    }
}
```

例如

```js
// 创建对象
const student = {
    name:"小明",
    age:18,
    sayHi:()=>{
        console.log("你好")
    }
}

// 访问属性
console.log(student.name)
console.log(student.age)
// 调用方法
student.sayHi();

// ...后续代码执行的过程中为对象添加属性或方法
// 对象名.属性名 : 如果该对象没有这个属性则为添加
student.score = 100.0;
console.log(student.score);

student.study=()=>{
    console.log("我是stydy方法")
}
student.study()
```

#### 10.2 箭头函数与js对象

- 如果箭头函数的函数体只有一句代码并且返回的是js对象，而不是简单的js表达式

  ```js
  // 箭头函数如果返回js对象,完整写法没问题
  let getUser = ()=> {
   	return {name:"小明",age:18}    //返回js对象
  }
  
  // 简化写法:如果函数体只有一句话{} 可以省。return如果只有一句话 return可以省
  // 错误的元素: 函数把对象的{}当成了函数体
  let getUser = ()=> {name:"小明",age:18}
  
  //正确的简化写法
  let getUser = ()=> ({name:"小明",age:18})
  ```


### 十一.数组

- 特点:

  ```js
  1. js中的数组长度不固定，可以任意扩展空间，可以存储任意类型的数据
  2. 操作数组时需要使用下标进行操作，数组提供了length属性，用于获取数组长度(与java一致)
  3. 数组提供了sort()方法，可以直接调用进行升序排列
  ```

- 定义语法:

  ```js
  1. const array = []; //空数组
  2. const array = [元素1,元素2,元素3...];
  ```

- 数组的遍历:

  ```java
  for(let i = 0; i<数组名.length; i++){
      数组名[i]
  }
  ```

- 数组的排序:

  ```js
  数组名.sort()
  ```

- 自定义排序:

  ```js
  // 数组存储复杂数据
  const array = [
      {
          max:3,
          avg:4,
          min:1
      },
      {
          max:3,
          avg:2,
          min:1
      },
      {
          max:5,
          avg:2,
          min:1
      }
  ]
  // 根据max字段对array数组进行排序，从小到大的顺序
  // x,y就是比较数组的单个元素，这里就是array数组中的每一个元素
  // 返回值: 整数
  // 方式1:普通函数
  function sortByField(x,y){
      // return x.max - y.max  //升序: x - y
      return result = y.max - x.max;  //降序
  }
  
  array.sort(sortByField)
  
  // 方式2: 箭头函数
  array.sort((x,y)=>result = y.max - x.max)
  
  console.log(array)
  ```

  ![image-20230619144559006](G:\二阶段-java-WEB\assets\image-20230619144559006.png)

- 数组中的方法:

  ```js
  push(元素): 添加元素到数组末尾。
  	举例
  		const array = [1,2]
  		array.push(3) //添加元素到数组末尾
  		console.log(array)
  		结果: [1, 2, 3]
  
  pop() //删除数组末尾的元素，并返回
  splice(开始下标,删几个) //删除某个范围
  ```

### 十二.JSON标准【重点】

- JSON (JavaScript Object Notation) 概念: 前后端分离系统中，前段与后端的 `数据交互格式`,而不是一整编程语言。

- 语法:

  ```json
  JSON 就是一串字符串，只不过元素会使用特定的符号标注:
  	{}: 当数据是对象
  	[]: 当数据是数组
  	"": json中属性名或字符串类型的属性值必须用双引号
  例如:
  	'{"name":"小黑"}' : 可以理解为一个包含name为小黑的对象
  	'[{"name":"tom"},{"name":"jerry"}]' : 表示包含两个对象的数组
  ```

  #### 12.1 js对象和json串的区别

  ```java
  可以理解为: JSON 是 JS 对象的字符串表示法,它使用文本表示一个 JS 对象的信息，本质是一个字符串。
  例如:
  	const obj = {a:"hello",b:"world"}; //这是一个对象，属性名也可以用""
  	const json = '{"a":"hello","b":"world"}';  //这是一个 JSON 字符串
  ```

  #### 12.2 json串和js对象转换

  ```java
  要实现从 JSON 字符串转换为 JS 对象， 使用 JSON.parse() 方法:
  例如:
  	const json = '{"a":"hello","b":"world"}';  //这是一个 JSON 字符串
      // 转js对象
      const obj = JSON.parse(json);
  
  要实现从 js 对象转换为 JSON 字符串， 使用 JSON.stringify()方法:
  例如:
  	const obj = {a:"hello",b:"world"}  //定义js对象
      const json = JSON.stringify(obj)   //得到json字符串
  ```

### 十三.BOM模型

- 概念: Browser Object Model 浏览器对象模型

- 作用: 将整个浏览器窗口封装为 window 对象,并提供了一组与浏览器相关的内置对象和方法

- window 对象的组成:

  ```java
  1. history: 存储浏览器浏览历史
  2. location: 管理url地址
  ```

  <img src="G:\二阶段-java-WEB\assets\image-20230619164315831.png" alt="image-20230619164315831" style="zoom:50%;" />

#### 13.1 window对象常用方法

- 警告框

  ```js
  window.alter("警告!!!")
  ```


- 确认框 【重点】

  ```java
  let result = window.confirm("确定删除吗?")
  点击ok返回true
  点击cancel返回false
  ```


- 提示输入框

  ```java
  let result = window.prompt("请输入你暗恋的人")
  点击ok获取输入的内容
  点击cancel得到null
  ```

  ![image-20230619165447517](G:\二阶段-java-WEB\assets\image-20230619165447517.png)

- 注意: 使用window对象下的内容，可以省略window的书写。例如: alter("")  confirm("")    prompt("")

#### 13.2 location.href【重点】

- 作用: 跳转到指定的url

- 语法:

  ```js
  location.href = "url"
  ```

### 十四.外部的js文件引入

- script标签中的js只对当前页面有效，如果要复用这段代码，就需要使用外部js的方式

#### 14.1 把script标签中的js代码抽取到一个后缀为.js的文件中

  ```js
//test.js
function sum(a,b){
	return a+b;
}
  ```

注意: js文件一般放在js文件夹里，另外js文件中不包含script标签

#### 14.2 使用script标签引入外部的js文件

```html
<script src="路径"></script>
```

## 第七章 Vue

### 一、介绍

#### 1.1Vue.js 是什么

Vue (读音 /vjuː/，类似于 **view**) 是一套用于构建用户界面的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与[现代化的工具链](https://v2.cn.vuejs.org/v2/guide/single-file-components.html)以及各种[支持类库](https://github.com/vuejs/awesome-vue#libraries--plugins)结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。

如果你想在深入学习 Vue 之前对它有更多了解，我们[制作了一个视频](https://v2.cn.vuejs.org/v2/guide/index.html#)，带您了解其核心概念和一个示例工程。

如果你已经是有经验的前端开发者，想知道 Vue 与其它库/框架有哪些区别，请查看[对比其它框架](https://v2.cn.vuejs.org/v2/guide/comparison.html)。

#### 1.2起步

官方指南假设你已了解关于 HTML、CSS 和 JavaScript 的中级知识。如果你刚开始学习前端开发，将框架作为你的第一步可能不是最好的主意——掌握好基础知识再来吧！之前有其它框架的使用经验会有帮助，但这不是必需的。

#### 1.3安装

尝试 Vue.js 最简单的方法是使用 [Hello World 例子](https://codesandbox.io/s/github/vuejs/v2.vuejs.org/tree/master/src/v2/examples/vue-20-hello-world)。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以[创建一个 `.html` 文件](https://github.com/vuejs/v2.vuejs.org/blob/master/src/v2/examples/vue-20-hello-world/index.html)，然后通过如下方式引入 Vue：

```
<!-- 开发环境版本，包含了有帮助的命令行警告 -->
<script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
```

或者：

```
<!-- 生产环境版本，优化了尺寸和速度 -->
<script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
```

[安装教程](https://v2.cn.vuejs.org/guide/installation.html)给出了更多安装 Vue 的方式。请注意我们**不推荐**新手直接使用 `vue-cli`，尤其是在你还不熟悉基于 Node.js 的构建工具时。

如果你喜欢交互式的东西，你也可以查阅[这个 Scrimba 上的系列教程](https://scrimba.com/g/gvuedocs)，它揉合了录屏和代码试验田，并允许你随时暂停和播放。

#### 1.4声明式渲染

Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：

```
<div id="app">
  {{ message }}
</div>
var app = new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue!'
  }
})
```

Hello Vue!

我们已经成功创建了第一个 Vue 应用！看起来这跟渲染一个字符串模板非常类似，但是 Vue 在背后做了大量工作。现在数据和 DOM 已经被建立了关联，所有东西都是**响应式的**。我们要怎么确认呢？打开你的浏览器的 JavaScript 控制台 (就在这个页面打开)，并修改 `app.message` 的值，你将看到上例相应地更新。

注意我们不再和 HTML 直接交互了。一个 Vue 应用会将其挂载到一个 DOM 元素上 (对于这个例子是 `#app`) 然后对其进行完全控制。那个 HTML 是我们的入口，但其余都会发生在新创建的 Vue 实例内部。

除了文本插值，我们还可以像这样来绑定元素 attribute：

```
<div id="app-2">
  <span v-bind:title="message">
    鼠标悬停几秒钟查看此处动态绑定的提示信息！
  </span>
</div>
var app2 = new Vue({
  el: '#app-2',
  data: {
    message: '页面加载于 ' + new Date().toLocaleString()
  }
})
```

鼠标悬停几秒钟查看此处动态绑定的提示信息！

这里我们遇到了一点新东西。你看到的 `v-bind` attribute 被称为**指令**。指令带有前缀 `v-`，以表示它们是 Vue 提供的特殊 attribute。可能你已经猜到了，它们会在渲染的 DOM 上应用特殊的响应式行为。在这里，该指令的意思是：“将这个元素节点的 `title` attribute 和 Vue 实例的 `message` property 保持一致”。

如果你再次打开浏览器的 JavaScript 控制台，输入 `app2.message = '新消息'`，就会再一次看到这个绑定了 `title` attribute 的 HTML 已经进行了更新。

#### 1.5条件与循环

控制切换一个元素是否显示也相当简单：

```
<div id="app-3">
  <p v-if="seen">现在你看到我了</p>
</div>
var app3 = new Vue({
  el: '#app-3',
  data: {
    seen: true
  }
})
```

现在你看到我了

继续在控制台输入 `app3.seen = false`，你会发现之前显示的消息消失了。

这个例子演示了我们不仅可以把数据绑定到 DOM 文本或 attribute，还可以绑定到 DOM **结构**。此外，Vue 也提供一个强大的过渡效果系统，可以在 Vue 插入/更新/移除元素时自动应用[过渡效果](https://v2.cn.vuejs.org/v2/guide/transitions.html)。

还有其它很多指令，每个都有特殊的功能。例如，`v-for` 指令可以绑定数组的数据来渲染一个项目列表：

```
<div id="app-4">
  <ol>
    <li v-for="todo in todos">
      {{ todo.text }}
    </li>
  </ol>
</div>
var app4 = new Vue({
  el: '#app-4',
  data: {
    todos: [
      { text: '学习 JavaScript' },
      { text: '学习 Vue' },
      { text: '整个牛项目' }
    ]
  }
})
```

1. 学习 JavaScript
2. 学习 Vue
3. 整个牛项目

在控制台里，输入 `app4.todos.push({ text: '新项目' })`，你会发现列表最后添加了一个新项目。

#### 1.6处理用户输入

为了让用户和你的应用进行交互，我们可以用 `v-on` 指令添加一个事件监听器，通过它调用在 Vue 实例中定义的方法：

```vue
<div id="app-5">
<p>{{ message }}</p>
<button v-on:click="reverseMessage">反转消息</button>
</div>
<script>
var app5 = new Vue({
el: '#app-5',
data: {
message: 'Hello Vue.js!'
},
methods: {
reverseMessage: function () {
this.message = this.message.split('').reverse().join('')
}
}
})
</script>
```

Hello Vue.js!

反转消息

注意在 `reverseMessage` 方法中，我们更新了应用的状态，但没有触碰 DOM——所有的 DOM 操作都由 Vue 来处理，你编写的代码只需要关注逻辑层面即可。

Vue 还提供了 `v-model` 指令，它能轻松实现表单输入和应用状态之间的双向绑定。

```
<div id="app-6">
  <p>{{ message }}</p>
  <input v-model="message">
</div>
var app6 = new Vue({
  el: '#app-6',
  data: {
    message: 'Hello Vue!'
  }
})
```

Hello Vue!

#### 1.7组件化应用构建

组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树：


在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单：

```
// 定义名为 todo-item 的新组件
Vue.component('todo-item', {
  template: '<li>这是个待办项</li>'
})

var app = new Vue(...)
```

现在你可以用它构建另一个组件模板：

```
<ol>
  <!-- 创建一个 todo-item 组件的实例 -->
  <todo-item></todo-item>
</ol>
```

但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个 [prop](https://v2.cn.vuejs.org/v2/guide/components.html#通过-Prop-向子组件传递数据)：

```
Vue.component('todo-item', {
  // todo-item 组件现在接受一个
  // "prop"，类似于一个自定义 attribute。
  // 这个 prop 名为 todo。
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})
```

现在，我们可以使用 `v-bind` 指令将待办项传到循环输出的每个组件中：

```
<div id="app-7">
  <ol>
    <!--
      现在我们为每个 todo-item 提供 todo 对象
      todo 对象是变量，即其内容可以是动态的。
      我们也需要为每个组件提供一个“key”，稍后再
      作详细解释。
    -->
    <todo-item
      v-for="item in groceryList"
      v-bind:todo="item"
      v-bind:key="item.id"
    ></todo-item>
  </ol>
</div>
Vue.component('todo-item', {
  props: ['todo'],
  template: '<li>{{ todo.text }}</li>'
})

var app7 = new Vue({
  el: '#app-7',
  data: {
    groceryList: [
      { id: 0, text: '蔬菜' },
      { id: 1, text: '奶酪' },
      { id: 2, text: '随便其它什么人吃的东西' }
    ]
  }
})
```

1. 蔬菜
2. 奶酪
3. 随便其它什么人吃的东西

尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。子单元通过 prop 接口与父单元进行了良好的解耦。我们现在可以进一步改进 `<todo-item>` 组件，提供更为复杂的模板和逻辑，而不会影响到父单元。

在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。在[后续教程](https://v2.cn.vuejs.org/v2/guide/components.html)中我们将详述组件，不过这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的：

```
<div id="app">
  <app-nav></app-nav>
  <app-view>
    <app-sidebar></app-sidebar>
    <app-content></app-content>
  </app-view>
</div>
```

##### 1.7.1与自定义元素的关系

你可能已经注意到 Vue 组件非常类似于**自定义元素**——它是 [Web 组件规范](https://www.w3.org/wiki/WebComponents/)的一部分，这是因为 Vue 的组件语法部分参考了该规范。例如 Vue 组件实现了 [Slot API](https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md) 与 `is` attribute。但是，还是有几个关键差别：

1. Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前 Safari 10.1+、Chrome 54+ 和 Firefox 63+ 原生支持 Web Components。相比之下，Vue 组件不需要任何 polyfill，并且在所有支持的浏览器 (IE9 及更高版本) 之下表现一致。必要时，Vue 组件也可以包装于原生自定义元素之内。
2. Vue 组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。

虽然 Vue 内部没有使用自定义元素，不过在应用使用自定义元素、或以自定义元素形式发布时，[依然有很好的互操作性](https://custom-elements-everywhere.com/#vue)。Vue CLI 也支持将 Vue 组件构建成为原生的自定义元素。

### 二、深入了解组件

#### 2.1组件注册

> 该页面假设你已经阅读过了[组件基础](https://v2.cn.vuejs.org/v2/guide/components.html)。如果你还对组件不太了解，推荐你先阅读它。

##### 2.1.1组件名

在注册一个组件的时候，我们始终需要给它一个名字。比如在全局注册的时候我们已经看到了：

```
Vue.component('my-component-name', { /* ... */ })
```

该组件名就是 `Vue.component` 的第一个参数。

你给予组件的名字可能依赖于你打算拿它来做什么。当直接在 DOM 中使用一个组件 (而不是在字符串模板或[单文件组件](https://v2.cn.vuejs.org/v2/guide/single-file-components.html)) 的时候，我们强烈推荐遵循 [W3C 规范](https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name)中的自定义组件名 (字母全小写且必须包含一个连字符)。这会帮助你避免和当前以及未来的 HTML 元素相冲突。

你可以在[风格指南](https://v2.cn.vuejs.org/v2/style-guide/#基础组件名-强烈推荐)中查阅到关于组件名的其它建议。

###### 2.1.1.1组件名大小写

定义组件名的方式有两种：

使用 kebab-case

```
Vue.component('my-component-name', { /* ... */ })
```

当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 `<my-component-name>`。

使用 PascalCase

```
Vue.component('MyComponentName', { /* ... */ })
```

当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 `<my-component-name>` 和 `<MyComponentName>` 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。

##### 2.1.2全局注册

到目前为止，我们只用过 `Vue.component` 来创建组件：

```
Vue.component('my-component-name', {
  // ... 选项 ...
})
```

这些组件是**全局注册的**。也就是说它们在注册之后可以用在任何新创建的 Vue 根实例 (`new Vue`) 的模板中。比如：

```
Vue.component('component-a', { /* ... */ })
Vue.component('component-b', { /* ... */ })
Vue.component('component-c', { /* ... */ })

new Vue({ el: '#app' })
<div id="app">
  <component-a></component-a>
  <component-b></component-b>
  <component-c></component-c>
</div>
```

在所有子组件中也是如此，也就是说这三个组件*在各自内部*也都可以相互使用。

##### 2.1.3局部注册

全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。

在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件：

```
var ComponentA = { /* ... */ }
var ComponentB = { /* ... */ }
var ComponentC = { /* ... */ }
```

然后在 `components` 选项中定义你想要使用的组件：

```
new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
```

对于 `components` 对象中的每个 property 来说，其 property 名就是自定义元素的名字，其 property 值就是这个组件的选项对象。

注意**局部注册的组件在其子组件中\*不可用\***。例如，如果你希望 `ComponentA` 在 `ComponentB` 中可用，则你需要这样写：

```
var ComponentA = { /* ... */ }

var ComponentB = {
  components: {
    'component-a': ComponentA
  },
  // ...
}
```

或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：

```
import ComponentA from './ComponentA.vue'

export default {
  components: {
    ComponentA
  },
  // ...
}
```

注意在 ES2015+ 中，在对象中放一个类似 `ComponentA` 的变量名其实是 `ComponentA: ComponentA` 的缩写，即这个变量名同时是：

- 用在模板中的自定义元素的名称
- 包含了这个组件选项的变量名

##### 2.1.4模块系统

如果你没有通过 `import`/`require` 使用一个模块系统，也许可以暂且跳过这个章节。如果你使用了，那么我们会为你提供一些特殊的使用说明和注意事项。

###### 2.1.4.1在模块系统中局部注册

如果你还在阅读，说明你使用了诸如 Babel 和 webpack 的模块系统。在这些情况下，我们推荐创建一个 `components` 目录，并将每个组件放置在其各自的文件中。

然后你需要在局部注册之前导入每个你想使用的组件。例如，在一个假设的 `ComponentB.js` 或 `ComponentB.vue` 文件中：

```
import ComponentA from './ComponentA'
import ComponentC from './ComponentC'

export default {
  components: {
    ComponentA,
    ComponentC
  },
  // ...
}
```

现在 `ComponentA` 和 `ComponentC` 都可以在 `ComponentB` 的模板中使用了。

###### 2.1.4.2基础组件的自动化全局注册

可能你的许多组件只是包裹了一个输入框或按钮之类的元素，是相对通用的。我们有时候会把它们称为[基础组件](https://v2.cn.vuejs.org/v2/style-guide/#基础组件名-强烈推荐)，它们会在各个组件中被频繁的用到。

所以会导致很多组件里都会有一个包含基础组件的长列表：

```
import BaseButton from './BaseButton.vue'
import BaseIcon from './BaseIcon.vue'
import BaseInput from './BaseInput.vue'

export default {
  components: {
    BaseButton,
    BaseIcon,
    BaseInput
  }
}
```

而只是用于模板中的一小部分：

```
<BaseInput
  v-model="searchText"
  @keydown.enter="search"
/>
<BaseButton @click="search">
  <BaseIcon name="search"/>
</BaseButton>
```

如果你恰好使用了 webpack (或在内部使用了 webpack 的 [Vue CLI 3+](https://github.com/vuejs/vue-cli))，那么就可以使用 `require.context` 只全局注册这些非常通用的基础组件。这里有一份可以让你在应用入口文件 (比如 `src/main.js`) 中全局导入基础组件的示例代码：

```
import Vue from 'vue'
import upperFirst from 'lodash/upperFirst'
import camelCase from 'lodash/camelCase'

const requireComponent = require.context(
  // 其组件目录的相对路径
  './components',
  // 是否查询其子目录
  false,
  // 匹配基础组件文件名的正则表达式
  /Base[A-Z]\w+\.(vue|js)$/
)

requireComponent.keys().forEach(fileName => {
  // 获取组件配置
  const componentConfig = requireComponent(fileName)

  // 获取组件的 PascalCase 命名
  const componentName = upperFirst(
    camelCase(
      // 获取和目录深度无关的文件名
      fileName
        .split('/')
        .pop()
        .replace(/\.\w+$/, '')
    )
  )

  // 全局注册组件
  Vue.component(
    componentName,
    // 如果这个组件选项是通过 `export default` 导出的，
    // 那么就会优先使用 `.default`，
    // 否则回退到使用模块的根。
    componentConfig.default || componentConfig
  )
})
```

记住**全局注册的行为必须在根 Vue 实例 (通过 `new Vue`) 创建之前发生**。[这里](https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js)有一个真实项目情景下的示例。

## 第八章 tomcat

#### 1. 应用程序体系结构

1.  B/S结构：（Browser浏览器 / Server服务器）

    特点：
    ```css
    使用浏览器作为客户端（Client）通过http协议与服务器通讯，从服务器中获取数据或发送数据
    ```
    ![](image/image_Pb6Q6705cO.png)
    ```markdown
    ## 浏览器(客户端)
      1. 数据展示
      2. 收集用数据
      3. 发送请求和数据给服务器
    
    ## 服务器
      特点：
        可以接受多个浏览器，多个用户访问
      职责：
      1. 接受请求和数据
      2. 处理数据
      3. 返回处理结果
    
    ```
2.  BS结构工作流程:
    -   步骤：
        ```css
        1.用户使用浏览器输入URL访问tomcat服务器  
        2.tomcat服务器从URL中获取用户要访问的文件名称或程序标识  
        3.tomcat服务器将文件内容回传到浏览器中或执行指定程序将结果返回到浏览器中  
        4.浏览器将文件或数据显示给用户
        ```
        工作原理示意图&#x20;

#### 2. 安装Tomcat

-   安装服务器软件&#x20;

    apache组织开发的Tomcat服务器软件，轻量级，开源免费&#x20;

    ![](image/image_E2szohVGd4.png)

    访问：[https://tomcat.apache.org/](https://tomcat.apache.org/ "https://tomcat.apache.org/") 进行下载

    安装步骤：
    ```markdown
    1. 解压tomcat安装包（解压版），解压目录不要存在中文或特殊符号
    2. 进入tomcat目录中的bin目录双击运行startup.bat 启动服务器
    3. 打开浏览器在地址栏输入http://127.0.0.1:8080 并访问
    4. 看到主页后证明启动成功，关闭窗口或执行bin目录中的shutdown.bat
    
    注意：Tomcat运行需要jdk，务必检查JAVA_HOME环境变量是否正确配置
    ```
    -   Tomcat目录结构

        ![](image/image_nf73KWR_xr.png)

#### 3. 发布（部署）静态网页

-   将静态网页项目拷贝到webapps目录中，作为自己的一个web应用

-   部署后的目录结构


#### 4. 访问静态资源

1.  打开浏览器，在地址栏输入URL URL(Uniform Resource Locator)：

    统一资源定位符，通过URL可以定位到远程服务器中的一个资源或程序标识&#x20;

    URL结构：
    ```markdown
    协议://ip:端口/web应用名/资源名
    ```
    例如:
    ```markdown
    http://192.168.0.3:8989/ems/login.html
    ```

#### 5. url相关概念

相关概念:

```markdown
1. IP地址：互联网上的每一个网络和每一台主机分配一个逻辑地址
2. 端口：操作系统为程序分配的唯一标识，范围0~65535
3. url:http://192.168.0.3:8989/ems/login.html
4. uri:/ems/login.html(通常供内部程序使用)
5. url-pattern:login.html(通常供内部程序使用)
```

#### 6. HTTP常见状态码

1. 404

   响应失败，无法找到页面

   

2. 200

   响应成功，也就是服务器找到了客户端请求的内容，并且将内容返回给客户端

## 第九章 servlet

### 一、将tomcat集成到idea

Settings->tomcat->本地tomcat地址

### 二、将项目部署到tomcat

Edit Configurations->add->tomcat:local->add artifict

### 三、Json对象之间的相互转化

#### 1.对象转化为json

```java
ObjectMapper mapper = new ObjectMapper();
//将对象转化Json
Student s = new Student("张三",18);
String student = mapper.writeAsString(s);
//将集合转化为json
List<String> list = new ArrayList<>();
list.add("张三");
list.add("李四");
String s3 = objectMapper.writeValueAsString(list);
resp.getWriter().write(s3);
//将map转化为json
 Map<String,String> map = new HashMap<>();
map.put("name","张三");
map.put("age","18");
String s2 = objectMapper.writeValueAsString(map);
resp.getWriter().write(s2);
```

#### 2.json转化为对象

```java
ObjectMapper mapper = new ObjectMapper;
//json转换成对象
Student s = mapper.readValue(req.getReader(),new TypeReference<Student>(){});
//json转换成集合
List<Student> list = mapper.readValue(req.getReader(),new TypeReference<List<Student>>(){});
//json转换为map
Map<String,String> map = mapper.readValue(req.getReader(),new TypeReference<Map<String,String>(){});
```

### 四、注解

#### 1.@JsonProperty

```
这是一个注解，映射了json和对象之间的映射关系

举例：
	如果在student类中属性名称为name，如果我在其上加上了JsonPropertity("username")，当这个对象转化为json字符串时，在json字符串中就会转化为"username"="..."，收参时也会用到。
```

#### 2.@JsonIgnore

```
一个注解，表示在转换成json字符串时，忽略这个属性
```

3.@JsonInclude

```
一个注解，于JsonIgnore正好相反
```

4.@JsonFormat

```
一个注解，将制定的属性进行json字符串转换时，给定其格式，如日期yyyy-MM-dd HH:mm:ss
@JsonFormat(pattern=("yyyy-MM-dd HH:mm:ss"),timezone="GMT+8")
```

### 五、servlet+axios前后端页面交互

![servlet-pic](https://raw.githubusercontent.com/Better-Bclear/pic/main/servlet-pic.png)

#### 1.前端发送请求

```js
axios.get("后端地址").then(res=>{
	//接收响应后处理
}).catch(err=>{
	//处理错误
})
```

#### 2.后端接收请求后处理数据

```java
ObjectMapper mapper = new ObjectMapper;
//json转换成对象
Student s = mapper.readValue(req.getReader(),new TypeReference<Student>(){});
//调用service层的方法
```

#### 3.后端发送响应

```java
resp.setContentType("text/json;charset=utf-8");
PrintWriter out = resp.getWriter();
out.write("要发送的json")
```

#### 4，注意点

```
servlet类中不要定义成员变量，以免两个线程之间争夺同一个资源
```

#### 5.执行流程

```
1.获取路径，并根据路径茶皂对应的servlet
2.根据包名和类名以反射的形式创建对象
3.通过对象调用service方法，tomcat创建request和response对象传递给service方法
4.在service方法中，调用业务代码就会运行，最后完成响应
```



### 六、DEBUG

#### 1.八个按钮

```
Show Execution Point (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。

Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。

Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法，如第25行的put方法。

Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。

Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。

Drop Frame (默认无)：回退断点，后面章节详细说明。

Run to Cursor (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。
```

七、新零售管理平台

# Servlet\_day2

## 目录

-   [一. debug调试程序](#一-debug调试程序)
    -   [1. debug简介](#1-debug简介)
    -   [2. 开启debug](#2-开启debug)
    -   [3. debug中常用的调试按钮](#3-debug中常用的调试按钮)
    -   [4. Debug服务设置按钮](#4-Debug服务设置按钮)
-   [二.第一个程序进行Debug演示](#二第一个程序进行Debug演示)
-   [三. Servlet细节](#三-Servlet细节)
    -   [1. Servlet两种配置方式](#1-Servlet两种配置方式)
    -   [2. Servlet生命周期](#2-Servlet生命周期)
    -   [3.线程安全问题](#3线程安全问题)
    -   [4. servlet运行流程](#4-servlet运行流程)
    -   [5.【基本没有乱码问题】 解决idea启动tomcat乱码问题](#5基本没有乱码问题-解决idea启动tomcat乱码问题)
    -   [6. servlet常见错误](#6-servlet常见错误)
-   [四. Servlet实战-登录功能](#四-Servlet实战-登录功能)
-   [五.Servlet实战-查所有功能](#五Servlet实战-查所有功能)
-   [六.新零售管理平台](#六新零售管理平台)

### 一. debug调试程序

#### 1. debug简介

```java
为何要用 Debug?

眼看 12 月马上就要过去了，张三正在大学宿舍床上躺着，此刻的他既开心又发愁。

开心的是马上就能和女朋友一起跨年了，发愁的是自己 java 期末大作业一堆错误。

张三英语不好，看不懂控制台的报错语句，所以越想越烦躁。

突然，张三好像有了灵感，打开 IDEA 兴奋地敲了起来。正参与五黑的室友见状，不免有些好奇，都跑去看他的电脑

原来张三正在复制粘贴一堆打印语句。一室友实在看不下去了，问他：“你调试程序为啥不用 Debug ?”

“你写这么多 system 语句，不麻烦吗？最后交作业，你还要把这些打印语句一个个都删掉，太浪费时间了。”

所以我们写程序不要一遇到问题就写一堆 system 打印语句，真的很浪费时间。

而使用 Debug 可以追踪程序的执行过程，快速定位程序异常的位置，帮助我们快速找到出错的代码。

```

#### 2. 开启debug

- Debug 模式下的界面:

  ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_zHdQNLGrvw.png)

  ```java
  1. 以 Debug 模式启动服务。在开发中，我一般会直接以 Debug 模式运行程序，方便随时调试代码。
  2. 断点，我们可以在行数栏左侧直接单击设置，也可以使用快捷键 Ctrl+F8 设置或者取消断点。
  3. Debug 窗口：当请求到达第一个断点后，Debug 窗口会被激活。
  4. Debug 服务按钮：在这里我们可以开启、关闭 Debug 服务等。
  5. 调试 Debug 按钮：我们在调试过程中主要使用这几个按钮，鼠标悬浮按钮上面可以显示快捷键。
  6. 方法区：这里会显示调试过程中执行的方法。
  7. 参数区：这里会显示当前断点前所有参数的值。
  
  ```

#### 3. debug中常用的调试按钮

![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_7MDtxbgKMw.png)

1. 跳转到当前执行代码行

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_wVMYTdrQg_.png)

   我们先在一个页面设置一个断点，然后再切换到其他页面，点击这个按钮，发现又跳转到了执行代码所在的行：

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/84a159ff01c82e3886e744672363b984_efYgrJ8Ja7.gif)

2. 步过

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_ria_rO18bQ.png)

   `步过`就是一步一步往下走，跳过所有方法：

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/bb71d8d46d42b1ff766e3e543985a325_ppoXHD8Xi5.gif)

   上面的例子中即便是遇到了 system 打印方法和 test1 方法，也会跨过去继续往下执行。

3. 步入

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_gEz7UKNg26.png)

   在执行的过程中如果遇到了`自定义`的方法，可以进入方法内部，不会进入 JDK 类库中的方法。

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/1\)_eBR8jAg1gG.gif)

   上面的例子中，遇到了 system 方法会自动跨过去，但是遇到了自定义的方法，则会进入到方法中执行，等执行完则会返回到方法的调用处。

4. 强制步入

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_8a7V39LoNO.png)

   不管遇到 JDK 的类库方法还是自定义方法，都会进入到方法中执行。

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/2_JGsiXNxzn0.gif)

   上面的例子中不管遇到了JDK 类库中的 system 方法还是自定义的 test1方法，都会进入到方法中执行。

5. 步出

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_drpCtL0G1U.png)

   `步出`就是从进入的方法内部退回到方法调用处。

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/3_WF8yA-wSeH.gif)

   上面的例子中我们进入到了 test1 方法的内部，当点击**步出**按钮后，又回到了调用 test1 方法的地方。

6. 回退断点处

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_fNEPbWJvkp.png)

   `回退断点处`意思就是可以回退到指定方法的调用处。

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/4_YmLg9Wu9r3.gif)

   上面的例子中我们依次执行了 test1、test2、method2 方法，但是我们可以选择直接回退到 test1 方法的调用处。

   > 步出和回退断点的区别：
   >
   > -   都是回到方法的调用处
   > -   步出只能回到当前方法的调用处
   > -   回退断点可以回到指定方法的调用处，前提是该方法已经被执行过。

7. 定位到光标处

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_B689SVhhrr.png)

   如果我们写的代码有几百行，一步一步往下执行也比较费时间。这时候我们可以先把光标放到一个指定位置，然后点击`定位光标处`按钮，这时候代码就会立即执行到光标处了。

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/5_eqopXZP16D.gif)

   上面的例子中我们把鼠标光标移动到了下面某一行，然后点击`定位光标处`按钮，代码立刻执行到了这一行。

8. 计算表达式

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_M2bVq8KX0i.png)

   `计算表达式`可以帮助我们计算一些表达式的返回值。

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/6_u_DMBOtfhZ.gif)

   从上面的例子中可以看出，我们可以在调用某些方法之前使用一些自定义参数去计算该方法的返回值。

#### 4. Debug服务设置按钮

1. 执行到下一个断点处直到结束

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_ID1chr-bbc.png)

   该按钮的作用：如果下面有断点，就跳转到下一个断点处。如果没有，程序就执行结束。

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/7_3QD5gmSd_n.gif)

2. 断点静音

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_WFCjeyxELB.png)

   有时候我们在执行到某一步的时候已经知道了结果，但是后面还有一堆断点。我想让这些断点失效，但是第二次跟踪我还想用这些断点，这时候就可以使用`断点静音`。

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/8_IEeke6FWLD.gif)

3. 查看/清除断点

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_-jNRTfT3i_.png)

   我们在执行完代码后要清除所有断点，但是一个个去清除太浪费时间，这时候就可以使用这个按钮查看所有设置的断点，或者清除所有断点。

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/9_Z_KH35zgq_.gif)

4. 返回到第一个断点的地方

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_7OsVLhAwZp.png)

   代码执行到某一行想返回到第一个断点处:

   ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/10_V1BRgoDfiK.gif)

### 二.第一个程序进行Debug演示

> 断点设置老师自己决定，演示controller收参调用service，service调用dao的过程。

### 三. Servlet细节

#### 1. Servlet两种配置方式

- 使用web.xml（Servlet2.5之前使用）

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://xmlns.jcp.org/xml/ns/javaee" 
            xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1">
    <!--Servlet的第二种配置  -->
    <!--Servlet配置  -->
    <servlet>
    <!--名称  -->
      <servlet-name>hello</servlet-name>
      <!--Servlet的全称类名  -->
      <servlet-class>com.baizhi.servlet.FirstServlet</servlet-class>
    </servlet>
    <!--映射配置  -->
    <servlet-mapping>
    <!--名称  -->
      <servlet-name>hello</servlet-name>
      <!--设置访问路径  -->
      <url-pattern>/test</url-pattern>
    </servlet-mapping>
    
    <!-- 访问应用路径展示的主页 -->
    <welcome-file-list>
      <welcome-file>login.html</welcome-file>
    </welcome-file-list>
  </web-app>
  ```

- 2.3.3 使用注解 （Servlet3.0后支持，推荐）

  ```java
  /**
   * 演示Servlet注解式配置
   */
  @WebServlet("/test")
  public class HelloServlet extends HttpServlet {
    
    @Override
      protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
  
      }
  }
  ```

#### 2. Servlet生命周期

- 目前自定义servlet是继承HttpServlet, Servlet顶层父接口是Servlet接口，里面包含生命周期方法

- 自定义类实现Servlet覆盖方法

  ```java
  import javax.servlet.*;
  import java.io.IOException;
  
  @WebServlet("/self")
  public class SelfController implements Servlet {
      public SelfController() {
          System.out.println("创建");
      }
  
      @Override
      public void init(ServletConfig servletConfig) throws ServletException {
          System.out.println("初始化方法");
      }
  
      @Override
      public ServletConfig getServletConfig() {
          return null;
      }
  
      @Override
      public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
          System.out.println("处理请求");
      }
  
      @Override
      public String getServletInfo() {
          return null;
      }
  
      @Override
      public void destroy() {
          System.out.println("销毁方法");
      }
  }
  ```

- 通过浏览器多次访问该servlet

  ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_dpb3tuGqrn.png)

- 访问后的结果输出

  ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_8Cl7xtWC5i.png)

  | 生命周期阶段 | 调用方法    | 何时调用             | 调用几次 |
  | ------------ | ----------- | -------------------- | -------- |
  | 创建         | 构造方法    | client第一次请求     | 1        |
  | 初始化       | init方法    | 对象创建后调用       | 1        |
  | 服务         | service方法 | client有请求就会调用 | n        |
  | 销毁         | destory方法 | server停止           | 1        |

  > 📌注意:Servlet在tomcat整个启动过程中，只创建一个对象,默认是client发起第一次请求时创建。servlet采用的是单例设计模式

#### 3.线程安全问题

- 通过学习Servlet的生命周期，我们得出一个结论：Servlet对象是单例的，当Servlet中定义属性后，并发访问下线程不安全。

  ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_Fbn3SDAo10.png)

解决办法：

-   service方法加锁，但是性能低下，不推荐
-   Servlet中不再定义属性，避免多线程争用同1个Servlet对象属性的可能，推荐

#### 4. servlet运行流程

- 掌握Servlet的请求响应执行流程，能帮我们更深刻的理解Servlet的运行细节，对于灵活使用Servlet和异常的解决有着指导意义。

  ![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_wJ-C1w5IqO.png)

Servlet的执行流程如下：

1.  Tomcat根据请求访问Servlet
2.  Tomcat创建request和response对象
3.  调用service方法
4.  service方法中收参、调用业务层并响应结果

#### 5.【基本没有乱码问题】 解决idea启动tomcat乱码问题

![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_6H3ITN7SlQ.png)

> 📌文件最后一行加入: `  -Dfile.encoding=utf-8  `,然后重启idea。

#### 6. servlet常见错误

- 学习完Servlet后，JavaWeb原始技术体系就学习完毕了。引入新的技术，就有新的异常，下面是Servlet中常见的异常

- 404 not found

  ```java
  原因：找不到资源
  - 可能是路径写错了 
  - tomcat加载项目时已经错了
  
  调错步骤：
  1. 启动tomcat后，先看控制台有无异常 
  2. 看路径是否正确
  
  ```

- 500 服务器内部异常

  ```java
  原因：服务器tomcat在运行程序时出现异常
  - Servlet代码逻辑有问题
  - tomcat启动时加载项目出了问题
  
  调错步骤：
  1. 启动tomcat后，先看控制台有无异常 
  2. 看代码逻辑，使用debug调试。
  ```

- 405

  ```java
  原因：service方法重写有问题
  调错步骤：查看servlet中service方法，看方法名、形参类型有没有错
  ```

  > 📌推荐: 每名同学将自己常见的错误，或者经过很长时间解决的刁钻错误通过笔记的形式记录。

### 四. Servlet实战-登录功能

![](/Users/jinzhanqing/Library/Containers/com.tencent.xinWeChat/Data/Library/Application Support/com.tencent.xinWeChat/2.0b4.0.9/4245a0c49008811b42eda0cda7d4ff76/Message/MessageTemp/07862b1d1afbbf747057e9831417a911/File/image/image_D2dUQSws8s.png)

-   将bootstrap中的登录页面赋值到当前项目中
-   依然基于user表完成登录功能

### 五.Servlet实战-查所有功能

-   老师根据班级情况定义表完成此功能

### 六.新零售管理平台

[新零售后台管理.rar](file/新零售后台管理_1aFt_iPQvY.rar "新零售后台管理.rar")

&#x20;mobile varchar(20),
&#x20;   sex varchar(3),
&#x20;   age int,
&#x20;   description varchar(200)
);

```java
-- 用户表
create table t_user(
  user_id int primary key,
    user_name varchar(20) unique not null,
    password varchar(20),
    mobile varchar(20),
    sex varchar(3),
    age int,
    description varchar(200)
);

-- 类别表
create table t_category(
  category_id int primary key comment '类别编号',
    category_name varchar(50) comment '类别名',
    description varchar(50) comment '类别说明'
);

insert into t_category values(1,'衣服','漂漂亮亮五颜六色的衣服');
insert into t_category values(2,'鞋子','漂漂亮亮五颜六色的鞋子');
insert into t_category values(3,'项链','漂漂亮亮亮晶晶的项链');
insert into t_category values(4,'包包','漂漂亮亮五颜六色的包包');
insert into t_category values(5,'娃娃','漂漂亮亮五颜六色的娃娃');

-- 商品表
create table t_goods(
  goods_id int primary key auto_increment comment '商品编号',
    goods_name varchar(20) comment '商品名称',
    stock int comment '商品库存',
    cost_price decimal(10,2) comment '进货价' ,
    retail_price decimal(10,2) comment '零售价',
    discount decimal(5,2) comment '折扣',
    status tinyint comment '状态：1上架 0下架',
    category_id int comment '类别id',
    list_time date comment '上架时间',
    create_time datetime comment '创建时间',
    update_time datetime comment '更新时间',
    introduction varchar(200) comment '商品介绍'
);
```

-   整个系统包含6个功能，功能流程图如下：

1.  注册功能

2.  登录功能

3.  查询商品功能

4.  添加功能

5.  删除功能

6.  更新功能

### 七、HTTP Cookie

#### 目录

-   [一. 跟踪用户状态](#一-跟踪用户状态)
    -   [1.1 概念分析](#11-概念分析)
    -   [1.2 http的无状态性](#12-http的无状态性)
-   [二.Cookie](#二Cookie)
    -   [2.1 Cookie的设计思路](#21-Cookie的设计思路)
    -   [2.2 Cookie的技术细节](#22-Cookie的技术细节)
-   [三. HttpSession ](#三-HttpSession-)
    -   [3.1 HttpSession的设计思路](#31-HttpSession的设计思路)
    -   [3.2 HttpSession的技术细节](#32-HttpSession的技术细节)
    -   [3.3 Session的典型应用](#33-Session的典型应用)
        -   [3.3.1 强制登录](#331-强制登录)
        -   [3.3.2 验证码](#332-验证码)
-   [四. Session和Cookie的关系](#四-Session和Cookie的关系)

#### 一. 跟踪用户状态

##### 1.1 概念分析

跟踪用户状态指的是web应用能够分辨请求属于哪个用户，进而记录用户的状态变化，从而为用户提供`连续的针对性的`服务。比如有多个客户在同1个购物网站上购物，每一个用户都会有一个虚拟的购物车。当某个客户发送请求将商品添加到购物车时，Web服务器必须能识别请求属于哪个用户，从而将商品添加该用户的购物车中。

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_Z4fMeKK5i8.png)

大多数的Web应用都需要跟踪用户状态，才能提供对应的服务。常见需要跟踪用户状态的应用：

-   电子商务
-   管理系统

也有一些简单的Web应用不需要跟踪用户状态。一些不需要跟踪用户状态的应用：

-   门户新闻网站
-   软件下载网站

##### 1.2 http的无状态性

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_d5ae22TGMF.png)

http协议是无状态的。每发起一次请求，就就创建一个新的连接，当结果响应结束后，连接就会被关闭。1个用户的多次请求和多个用户各发1次请求对于Web服务器而言是没有区别的。Web服务器无法根据连接分辨请求属于哪一个用户，http协议本身没有分辨用户，跟踪用户状态的功能。

解决方案：

-   Cookie
-   HttpSession&#x20;

#### 二.Cookie

Cookie（点心），它是在客户端访问Web服务器时，服务器响应给客户端的信息，就好像服务器送给客户的“点心”。

##### 2.1 Cookie的设计思路

Cookie就好像生活中健身馆向会员发送的会员卡。会员卡记录会员的信息，健身馆根据会员卡的信息识别会员身份。

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_P8mpkVX_WU.png)

特点：

-   会员卡保存会员信息由健身馆生成
-   会员卡由顾客保存
-   会员卡一般都会有有效期
-   健身馆就是根据会员卡分辨识别用户

服务端生成包含用户信息的Cookie（键值对字符串），返回客户端。客户端再发起请求时，会自动携带Cookie到服务端，服务端可以获取Cookie，读取到用户信息从而识别用户。

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_H51iZfdFSu.png)

特点：

-   Cookie由服务端生成
-   Cookie有client（浏览器）保存
-   Cookie都会有有效期
-   服务端根据cookie分辨识别用户

##### 2.2 Cookie的技术细节

Cookie的使用，我们主要关注2点：服务端如何创建Cookie，以及如何从请求中获取Cookie？

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_H51iZfdFSu.png)

Cookie有效期的设置：

```java
/*
  Cookie有效期，默认等同于浏览器。（浏览器关闭，Cookie销毁）
  可以通过cookie.setMaxAge(存活时长)设置其有效期
*/
c.setMaxAge(60*60*24*7);//单位秒
```

**示例代码：**

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_NDFEloRxgV.png)

**AddCookieServlet**

```java
@WebServlet("/addCookie")
public class AddCookieServlet extends HttpServlet{
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        Cookie cookie = new Cookie("name", "xushy");
        resp.addCookie(cookie);
    }
}
```

**GetCookiesServlet**

```java
@WebServlet("/getCookies")
public class GetCookiesServlet extends HttpServlet{
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        Cookie[] cookies = req.getCookies();
        if (cookies != null) {
            Arrays.stream(cookies).forEach(System.out::println);
        }

    }
}
```

**测试页面**

```html
<div id="app">
        <input type="button" value="访问AddCookieServlet，响应中返回cookie" @click="respCookie">
        <input type="button" value="访问GetCookiesServlet，请求中携带cookie" @click="reqCookies">
    </div>
    <script>
        new Vue({
            el:"#app",
            methods:{
                respCookie(){
                    axios.get("/servlet-day03/addCookie")
                        .then(resp=>console.log(resp))
                        .catch(error=>console.log(error));
                },
                reqCookies(){
                    axios.get("/servlet-day03/getCookies")
                        .then(resp=>console.log(resp))
                        .catch(error=>console.log(error));
                }
            }
        })
    </script>
```

测试效果：

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_AgOpuRgtfT.png)

Cookie的不足：

-   只能保存字符串数据
-   不能直接保存中文字符（tomcat8.5之后可以直接保存）
-   Cookie保存数据量有限，最多4K
-   Cookie不安全

Cookie的最佳实践：

使用Cookie保存少量的不重要的数据，比如：浏览记录，用户名

#### 三. HttpSession&#x20;

HttpSession会话，表示一个浏览器和服务端的多次交互过程。一个浏览器短时间内连续访问服务端始终对应着同1个HttpSession对象。

##### 3.1 HttpSession的设计思路

HttpSession对象就好像生活中宾馆的一个房间。一个住客在一个宾馆中居住的日子里始终居住在同1个房间，宾馆根据房间识别住客身份。

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_6xX5dCoe1g.png)

特点：

-   房间由宾馆分配
-   房间由宾馆管理
-   每一个房间都会有使用时限
-   宾馆根据房间和住客的对应关系分辨识别住客

HttpSession对象是由服务端创建的对象，占据服务器的一小块内存空间。一个浏览器（好比住客）多次访问服务端（好比宾馆）始终对应着同1个Session对象。服务端可以根据Session对象分别不同用户。

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_vDC8tCcJnv.png)

特点：

-   session由服务端创建
-   session保存再服务端，会占用服务器内存空间
-   session都会有默认的存活时长：距上一次访问30分钟&#x20;
-   服务端根据session分辨识别用户，session和浏览器是一一对应的关系。

##### 3.2 HttpSession的技术细节

**HttpSession的创建和获取**

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_e458eXs3gC.png)

无论何时获取Session，代码都是：req.getSession(); 如果是第1次获取服务器会新建一个Session，如果之前获取过则直接返回Session。

**HttpSession作用域对象的使用**

HttpSession本身还可以保存、获取数据，也就是可以当做作用域对象使用。因为同1个浏览器的多次请求获取到的是同1个Session，也就可以借助Session作用域在一个浏览器的多次请求间传递数据.

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_YgjfCpGbBe.png)

request和session作用范围：

-   request作用域的范围：在一次请求中
-   session的作用域范围：在一个浏览器的多次请求间

**session存活时长的设置**

session默认存活时长：距上一次访问30分钟

1. 修改tomcat/conf/web.xml ：作用于整个tomcat中所有的应用

   ```xml
   <session-config>
         <!-- 单位：分钟 -->
           <session-timeout>30</session-timeout>
   </session-config>
   ```

2. 修改当前web应用的web.xml: 作用于当前web应用

   ```xml
   <session-config>
         <!-- 单位：分钟 -->
           <session-timeout>10</session-timeout>
   </session-config>
   ```

3. 修改某一个session的存活时长：只作用于特定的session对象

   ```java
   HttpSession session = req.getSession();
   session.setMaxInActiveInterval(60);//单位秒
   ```

**session对象的销毁：**

1.  自然死亡：距上次时间超过设置值
2.  横死街头：session.invalidate();

##### 3.3 Session的典型应用

###### 3.3.1 强制登录

系统中有些功能，必须登录之后才能使用，如果用户没有登录，就使用这些功能，应该强制用户跳转到登录页面，重新登录。

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_NkyImSw2ng.png)

LoginController

```java
@WebServlet("/login")
public class LoginController extends HttpServlet{
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1 收参
        req.setCharacterEncoding("utf-8");
        String username = req.getParameter("username");
        String pwd = req.getParameter("pwd");

        //2 调用业务层方法
        //3 跳转
        UserService userService = new UserServiceImpl();
        if(userService.login(username,pwd)){
            HttpSession session = req.getSession();
            session.setAttribute("login",true);
            resp.sendRedirect("/servlet-day02/person/showPersons");
            return;
        }

        resp.sendRedirect("/servlet-day02/login.html");
    }
}
```

ShowAllPersonsController

```java
@WebServlet("/person/showPersons")
public class ShowPersonsController extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 强制登录判断
        HttpSession session = req.getSession();
        //从作用域中获取登录标识，如果获取不到说明没有登录，则重定向到登录页面
        Object login = session.getAttribute("login");
        if(login == null){
            resp.sendRedirect("/servlet-day02/login.html");
            return;
        }
        // 1 收参（省略）
        //2 调用业务层方法
        PersonService personService = new PersonServiceImpl();
        List<Person> persons = personService.listPersons();

        //借助request作用域传递数据
        req.setAttribute("persons",persons);
        //请求转发到showPersonsView
        req.getRequestDispatcher("/person/showPersonsView").forward(req,resp);

    }
}
```

###### 3.3.2 验证码

验证码：内容变化的图片。

验证码作用：通过验证码确认使用者是真实的用户，而非代码模拟的用户。避免破坏者的恶意行为（比如通过代码大量注册用户刷评分、黄牛通过程序抢票）。

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_VbTfwLs78E.png)

ValidateCodeController

```java
@WebServlet("/validateCode")
public class ValidateCodeController extends HttpServlet {
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //创建验证码
        LineCaptcha captcha = CaptchaUtil.createLineCaptcha(200, 100);
        //向session中保存验证码的真实内容
        String code = captcha.getCode();
        HttpSession session = req.getSession();
        session.setAttribute("realCode",code);

        //通过流将验证码响应回浏览器
        ServletOutputStream out = resp.getOutputStream();
        captcha.write(out);
    }
}
```

LoginController

```java
@WebServlet("/login")
public class LoginController extends HttpServlet{
    @Override
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //1 收参
        req.setCharacterEncoding("utf-8");
        String username = req.getParameter("username");
        String pwd = req.getParameter("pwd");
        String validateCode = req.getParameter("validateCode");

        // 先判断验证码
        HttpSession session = req.getSession();
        String realCode = (String) session.getAttribute("realCode");
        if (validateCode != null && !validateCode.equalsIgnoreCase(realCode)) {
            //如果验证码不正确，重定向到登录页面
            resp.sendRedirect("/servlet-day02/login.html");
            return;
        }

        //2 调用业务层方法
        //3 跳转
        UserService userService = new UserServiceImpl();
        if(userService.login(username,pwd)){
            session.setAttribute("login",true);
            resp.sendRedirect("/servlet-day02/person/showPersons");
            return;
        }

        resp.sendRedirect("/servlet-day02/login.html");
    }
}
```

#### 四. Session和Cookie的关系

Session和Cookie都可以用来实现跟踪用户状态，而二者是关系的：Session的实现依赖于Cookie。

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_BSsK76jCBR.png)

Session的底层原理：

1. 当client（浏览器）第1次发起请求并获取session后，服务端在服务器内部创建一个Session对象，并将该session的id以（JSESSIONID=id值）的cookie写回浏览器

   ![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_PJFWpaSazZ.png)

2. 当client（浏览器）二次请求时，会自动携带Cookie（也就是session的id）

   ![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_3Z3D5OyU7l.png)

3. 服务端根据cookie记录的id值获取相应的Session

   ![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_J7bGZgbwKL.png)

![截屏2023-06-28 16.40.57](https://raw.githubusercontent.com/Better-Bclear/pic/main/截屏2023-06-28 16.40.57.png)

![截屏2023-06-28 16.55.16](https://raw.githubusercontent.com/Better-Bclear/pic/main/%E6%88%AA%E5%B1%8F2023-06-28%2016.55.16.png)

#### 五、过滤器和拦截器

![](https://raw.githubusercontent.com/Better-Bclear/pic/main/%E6%88%AA%E5%B1%8F2023-07-03%2014.37.14.png)

##### 5.1 过滤器的编写

###### 5.1.1概念

> `Servlet` 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。
>
> 可以将一个或多个 `Servlet `过滤器附加到一个 Servlet 或一组 Servlet。`Servlet` 过滤器也可以附加到 `JavaServer Pages (JSP)` 文件和 HTML 页面。调用` Servlet `前调用所有附加的 Servlet 过滤器。

###### 5.1.2作用

> Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的：
>
> - 在客户端的请求访问后端资源之前，拦截这些请求。
> - 在服务器的响应发送回客户端之前，处理这些响应。

###### 5.1.3例子

> 根据规范建议的各种类型的过滤器：
>
> - 身份验证过滤器`（Authentication Filters）`。
> - 数据压缩过滤器`（Data compression Filters）`。
> - 加密过滤器`（Encryption Filters）`。
> - 触发资源访问事件过滤器。
> - 图像转换过滤器`（Image Conversion Filters）`。
> - 日志记录和审核过滤器`（Logging and Auditing Filters）`。
> - MIME-TYPE 链过滤器`（MIME-TYPE Chain Filters）`。
> - 标记化过滤器`（Tokenizing Filters）`。
> - XSL/T 过滤器`（XSL/T Filters）`，转换 XML 内容。

过滤器通过 Web 部署描述符（web.xml）中的 XML 标签来声明，然后映射到您的应用程序的部署描述符中的 Servlet 名称或 URL 模式。

当 Web 容器启动 Web 应用程序时，它会为您在部署描述符中声明的每一个过滤器创建一个实例。

Filter的执行顺序与在web.xml配置文件中的配置顺序一致，一般把Filter配置在所有的Servlet之前。

##### 5.2过滤器中的方法

| 1    | `public void doFilter (ServletRequest, ServletResponse, FilterChain)`·该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器。 |
| ---- | ------------------------------------------------------------ |
| 2    | **public void init(FilterConfig filterConfig)**<br/>web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。 |
| 3    | **public void destroy()**<br/>Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。 |

##### 5.3FilterConfig使用

Filter的init方法中提供了一个FilterConfig对象

```xml
<filter>
    <filter-name>LogFilter</filter-name>
    <filter-class>com.runoob.test.LogFilter</filter-class>
    <init-param>
        <param-name>Site</param-name>
        <param-value>菜鸟教程</param-value>
    </init-param>
</filter>
```

在init方法中使用FilterConfig对象获取参数

```java
public void init(FilterConfig config) throws ServletException {
    // 获取初始化参数
    String site = config.getInitParameter("Site"); 
    // 输出初始化参数
    System.out.println("网站名称: " + site); 
}
```

##### 5.4代码案例

```java
package com.runoob.test;

//导入必需的 java 库
import javax.servlet.*;
import java.util.*;

//实现 Filter 类
public class LogFilter implements Filter  {
    public void  init(FilterConfig config) throws ServletException {
        // 获取初始化参数
        String site = config.getInitParameter("Site"); 

        // 输出初始化参数
        System.out.println("网站名称: " + site); 
    }
    public void  doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws java.io.IOException, ServletException {

        // 输出站点名称
        System.out.println("站点网址：http://www.runoob.com");

        // 把请求传回过滤链
        chain.doFilter(request,response);
    }
    public void destroy( ){
        /* 在 Filter 实例被 Web 容器从服务移除之前调用 */
    }
}
```

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowCredentials(true)
                .allowedOriginPatterns("*")
                .allowedOrigins("http://localhost:8080")
                .allowedMethods("POST", "GET", "PUT", "OPTIONS", "DELETE", "HEAD")
                .allowedHeaders("*")
                .exposedHeaders("Header1", "Header2");
    }
}
```

##### 5.5拦截器

编写拦截器的代码

```java
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        HttpSession session = request.getSession();
        log.info(request.toString());
        String username = (String)session.getAttribute("username");
        System.out.println(username);
        System.out.println("执行了拦截器");
        return username != null;
    }
}
```

编写拦截器配置

```java
@Override
    public void addInterceptors(InterceptorRegistry registry) {
        InterceptorRegistration registration = registry.addInterceptor(new LoginInterceptor());
        //registration.addPathPatterns("/**"); //所有路径都被拦截
        registration.excludePathPatterns(    //添加不拦截路径
                "/user/login",                    //登录路径
                "/user/register"               //注册路径
//                "/**/*.html",                //html静态资源
//                "/**/*.js",                  //js静态资源
//                "/**/*.css"                  //css静态资源
        );
    }
}
```

#### 六.文件的上传

> 1.写出一个`input`类型为`file`
>
> 2.`axios`发送`post`请求
>
> 3.接收：1.js原生
>
> ​			   2.vue

```html
<html>
  <head>
    
  </head>
  <body>
   	选择你要上传的文件：<input type="file" id="aa"/>
    <button @click="upload">
      确认上传
    </button>
  </body>
</html>
<script>
  upload(){
    let a = document.getElementById('aa').files[0];
    const fd = new FormData();
    fd.append("file",a);
		axios.post("url",fd).then().catch()
  }
</script>

//注意点：1.input类型必须为file
				 2.axios请求方式必须为post
```

```html
<html>
  <head>
    
  </head>
  <body>
   	选择你要上传的文件：<input type="file" ref="bb"/>
    <button @click="upload">
      确认上传
    </button>
  </body>
</html>
<script>
  upload(){
    let a = this.$refs.bb.files[0];
		const fd = new FormData();
    fd.append("file",a);
		axios.post("url",fd).then().catch()
  }
</script>

//注意点：1.input类型必须为file
				 2.axios请求方式必须为post
```

```java
//Controller代码
@WebServlet
public class extends HttpServlet{
  public void servivce(HttpSevletRequest req,HttpServlet resp){
    //1.从请求中获取文件
    Part file = req.getPart("file");
    //2.使用输出流指向文件
    InputStreqm = file.getInputStream();
    //3.动态获取相对路径
    String realPath = req.getServletContext().getRealPath("/file/upload");
    //4.将文件存储为上传时的文件名
    FileOutputStream out = new FileOutputStream(realPath+"//"+file.getSbumitName());
  }
}
```

## Maven

<!---->

-   作用：Maven是apache组织提供的开源项目管理工具，用于对java项目进行整体构建 包括：清理、编译、测试、打包、部署等等
-   优势：
    1.  可以摆脱现有IDE规范：maven使用约定，明确约定所有资源文件的存放位置，方便一键式迁移项目  &#x20;
    2.  构建依赖 (解决系统的依赖检查)：依赖指的是jar包之间的相互依赖，使用Maven来管理项目中使用到的jar包，由 Maven“自动下载项目所需要的jar包，统一管理jar包之间的依赖关系，节省用户本地空间的占用  &#x20;
    3.  maven支持远程部署  &#x20;
    4.  &#x20;Maven(配置其它持续集成工具)可以完成持续集成|持续发布 (CI continuous integration)

### 一、环境搭建

- 下载Maven：

  <https://maven.apache.org/download.cgi>

  ![](/Users/jinzhanqing/机构/maven/image/maven下载_8ScnImenb9.png)

  直接点击下载：

  [apache-maven-3.8.1-bin.zip](file/apache-maven-3.8.1-bin_ea_H6LQN2N.zip "apache-maven-3.8.1-bin.zip")

- 解压安装&#x20;

  ![](/Users/jinzhanqing/机构/maven/image/maven解压_xtDGIuggOc.png)

  目录说明：

  ```markdown
  1. bin：存放maven启动执行脚本文件
  2. boot：存放启动maven的引导文件
  3. conf：存储maven的核心配置文件(settings.xml)
  4. lib：存储Maven工具运行时所需要的 jar 文件
  ```

- 配置环境变量

  1. 新增：MAVEN\_HOME 指定maven的安装根目录  &#x20;

     ![](/Users/jinzhanqing/机构/maven/image/配置Maven环境变量_s8F4BaSFa6.png)

  2. 在path中追加：maven安装目录\bin目录

     ![](/Users/jinzhanqing/机构/maven/image/配置Maven环境变量2_85RrToTFnl.png)

- 测试环境变量是否配置成功

  打开 cmd 窗口，输入命令 **mvn -v**
  配置成功显示以下内容

  ![](/Users/jinzhanqing/机构/maven/image/检查Maven环境变量_9ULs_Ffhrt.png)

   注意：maven3.3以上需要jdk7或以上版本支持

### 二、Maven仓库

-   作用：用于存储和管理Maven项目在构建过程中使用的所有jar包
-   配置文件位置：`maven安装目录\conf\settings.xml`

#### （一）本地仓库

- 本地仓库的默认位置：`C:\Users\用户名.m2\repository`

- 修改本地仓库的位置（可选）：&#x20;
  修改配置文件&#x20;

  ![](/Users/jinzhanqing/机构/maven/image/配置Maven本地仓库_XPMBokfQrZ.png)

#### （二）中央仓库&镜像仓库

- 作用：当本地仓库没有项目所依赖的jar文件时会去互联网中央仓库下载，由于仓库服务器在国外，所以加载较慢。

- 修改中央仓库位置，将地址修改为阿里的镜像仓库

  镜像仓库：将国外中央仓库中所有内容拷贝到国内的仓库中作为镜像（副本），让国内用户使用仓库更加方便、快捷
  修改配置文件&#x20;

  ![](/Users/jinzhanqing/机构/maven/image/maven中央仓库配置_JcqSbL1GAW.png)

  配置内容：

  ```xml
  <mirror>     
    <id>nexus-aliyun</id>    
    <mirrorOf>central</mirrorOf>    
    <name>Nexus aliyun</name>    
    <url>http://maven.aliyun.com/nexus/content/groups/public</url>
  </mirror>
  ```

#### （三）私服

-   作用：架设在局域网中的仓库，它本身可以代理互联网上的远程仓库（一般代理中央仓库或者阿里云镜像），为局域网中用户提供服务，也可将公司内部所使用的jar包部署到私服中供内部使用

#### （四）Maven仓库获取依赖顺序

![](/Users/jinzhanqing/机构/maven/image/maven仓库获取依赖顺序_j7QdyWrNm4.png)

在获取依赖时一旦在某一步找到需要的依赖，立刻返回，至少找到对应jar包，此jar包会被保存在本地仓库，以后使用jar包直接在本地仓库找jar包。

### 三、第一个Maven项目

- 使用maven命令创建基础项目

  ```powershell
  mvn archetype:generate -DgroupId=com.baizhi -DartifactId=hello_maven -DarchetypeArtifactId=maven-archetype-quickstart -DarchetypeVersion=1.4 -DinteractiveMode=false
  ```

   注意：项目会生成到cmd所指向的目录

  第一次使用需要等待maven下载依赖文件，成功后显示&#x20;

  ![](/Users/jinzhanqing/机构/maven/image/使用命令构建基础maven项目_u6Pf065FN1.png)

- 基础的Java项目目录结构&#x20;

  ![](/Users/jinzhanqing/机构/maven/image/maven基础目录结构_OdJ_Aef3k1.png)

   注意：maven项目必须保证目录结构的规范性，严格按照要求创建目录，否则无法使用

### 四、在idea配置maven

#### （一）打开设置

![](/Users/jinzhanqing/机构/maven/image/idea集成maven0_kmXzYYHATO.png)

#### （二）配置maven所在目录

![](/Users/jinzhanqing/机构/maven/image/idea集成maven_okC-OeW3Qu.png)

#### （三）设置本地仓库位置与settings.xml配置文件的位置

![](/Users/jinzhanqing/机构/maven/image/image_o4XChpw073.png)

### 五、创建maven项目

#### （一）新建maven项目

![](/Users/jinzhanqing/机构/maven/image/image_x6Df2Yrxrc.png)

#### （二）完成相关配置

![](/Users/jinzhanqing/机构/maven/image/image_wMfSkFI8nl.png)

#### （三）让idea重新加载maven项目以更新配置

![](/Users/jinzhanqing/机构/maven/image/image_5EtJDaQ7fn.png)

 注意：每次修改maven配置时记得让idea重新加载一下

#### （五）pom.xml结构

- pom.xml是maven项目的配置文件，所有与该项目有关的配置都要写在此文件中

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <project xmlns="http://maven.apache.org/POM/4.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <modelVersion>4.0.0</modelVersion>
  
      <!--  组织名称，一般采用域名倒置方式进行配置  -->
      <groupId>com.baizhi</groupId>
  
      <!--  项目名称  -->
      <artifactId>maven_demo</artifactId>
  
      <!--  项目版本号 -->
      <version>1.0-SNAPSHOT</version>
  
      <!-- 项目参数配置 -->
      <properties>
          <!--  JDK版本号   -->
          <maven.compiler.source>8</maven.compiler.source>
          <maven.compiler.target>8</maven.compiler.target>
      </properties>
  
  </project>
  
  ```

#### （六）修改pom.xml配置打包类型与编码方式

- 修改后pom.xml如下所示

  ```xml
  <project xmlns="http://maven.apache.org/POM/4.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <modelVersion>4.0.0</modelVersion>
  
      <!--  组织名称，一般采用域名倒置方式进行配置  -->
      <groupId>com.baizhi</groupId>
  
      <!--  项目名称  -->
      <artifactId>maven_demo</artifactId>
  
      <!--  项目版本号 -->
      <version>1.0-SNAPSHOT</version>
      
      <!--  web项目压缩为war包  -->
      <packaging>war</packaging>
  
      <!-- 项目参数配置 -->
      <properties>
          <!--  源文件的编解码方式 -->
          <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
          <!--  JDK版本号   -->
          <maven.compiler.source>8</maven.compiler.source>
          <maven.compiler.target>8</maven.compiler.target>
      </properties>
  
  </project>
  ```

### 六、Maven依赖管理

-   依赖是指项目中使用的第三方工具，jar包、配置文件、和一些其他资源，例如mysql-connector-java- \*.jar
-   传统手动依赖管理的问题：
    1.  操作繁琐，易于冲突：当需要的jar包或资源比较多事，导入起来很麻烦，多个jar包在不合理的搭配时会产生jar包冲突问题
    2.  浪费硬盘空间：为了项目能够正常运行，每个应用都需要在内部保存依赖jar包，避免移植后出现无法使用问题
    3.  项目扩展性差，维护难度高：当加入新的依赖时，要考虑冲突问题，当项目中的依赖需要升级也会很麻烦

#### （一）Maven的坐标

- 每个Maven项目都有一个坐标，坐标定义在pom.xml中作为该项目的唯一标识，在开发过程中如果需要使用三方依赖，也需要在pom.xml中明确其坐标方可使用

- 坐标的组成：

  ```xml
  <groupId>组织名：公司或组织名倒置</groupId>
  <artifactId>项目名</artifactId>
  <version>版本号</version>
  <packaging>打包方式（项目类型）
          jar：普通的java项目（默认）
          web：web项目
  </packaging>
  ```

#### （二）Maven依赖管理流程

- Maven的依赖管理流程分为以下两步

  1.  找到依赖坐标
  2.  在pom.xml中配置坐标导入依赖

- 例如系统中此时有三个Maven项目，maven-a、maven-b、maven-c，现在maven-b、maven-c项目中需要使用maven-a项目，那么需要按照以下流程进行

  ![](/Users/jinzhanqing/机构/maven/image/image_oa8BZuGnY9.png)

#### （三）在项目中配置依赖

- Maven项目的所有依赖要在pom.xml中的\<dependency>标签中进行配置。

- 可以通过Maven官方提供的搜索服务搜索jar包的坐标。

  <https://mvnrepository.com/>

- 配置依赖的基础形式
  在\<project>标签中进行配置

  ```xml
  <!--   dependecies标签负责管理所有依赖配置 -->
   <dependencies>
   
          <!-- 配置第一个依赖 -->
          <dependency>
              <groupId>坐标1</groupId>
              <artifactId>项目名称1</artifactId>
              <version>版本号</version>
          </dependency>
          
          <!-- 配置第二个依赖 -->
          <dependency>
              <groupId>坐标2</groupId>
              <artifactId>项目名称2</artifactId>
              <version>版本号</version>
          </dependency>
                 
  </dependencies>
  ```

- 例：配置JUnit单元测试依赖与mysql驱动依赖

  ```xml
  <project xmlns="http://maven.apache.org/POM/4.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
     
      <!-- 其他标签略....-->
      
      
      <!--   dependecies标签负责管理所有依赖配置 -->
      <dependencies>
          <!--  配置JUnit单元测试依赖  -->
          <dependency>
              <groupId>junit</groupId>
              <artifactId>junit</artifactId>
              <version>4.11</version>
          </dependency>
  ```


            <!-- 配置mysql-connector数据库驱动依赖 -->
            <dependency>
                <groupId>mysql</groupId>
                <artifactId>mysql-connector-java</artifactId>
                <version>8.0.23</version>
            </dependency>
    
        </dependencies>
    </project>
    ```

- Maven配置三步骤

  ```markdown
  1. 查找坐标
  2. 修改pom.xml配置文件，添加坐标
  3. 加载配置
  ```

- 在idea右侧的Dependencies目录中可以看到已经下载的依赖

  ![](/Users/jinzhanqing/机构/maven/image/image_RPYyP5yAXm.png)

### 七、依赖范围

- 作用：表名依赖jar或war包的作用时机与作用范围
  作用范围：

  ```markdown
  1. 编译依赖：项目 在 编码阶段, 需要 maven 提供的依赖。
  2. 测试依赖：项目 在 执行测试(mvn test)时, 所需要 maven 提供的依赖。
  3. 运行依赖：项目 在 web 容器中 运行时, 需要 maven 提供的依赖。
  4. 参与打包：项目 在 打包发布时是否将依赖一起打包
  
  ```

  依赖范围：

  | 依赖范围 | 编译依赖 | 测试依赖 | 运行依赖 | 参与打包 | 例                         |
  | -------- | -------- | -------- | -------- | -------- | -------------------------- |
  | compile  |         |         |         |         | jstl                       |
  | test     |         |         |         |         | junit                      |
  | provided |         |         |         |         | servlet-api、jsp-api       |
  | runtime  |         |         |         |         | mysql-connector-java       |
  | system   |         |         |         |         | （不推荐此配置）本地的依赖 |

- 在pom.xml中配置依赖范围
  需要在`<dependency>`中加入`<scope>`进行设置
  例如junit配置依赖范围

  ```xml
  <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
        <version>4.11</version>
        <!-- 配置依赖范围 -->
        <scope> test </scope>
  </dependency>
  ```

### 八、Maven的生命周期

- Maven的生命周期就是指Maven项目从项目初始化创建到开发完毕部署的完整过程。
  项目的生命周期包含很多阶段，不同的阶段maven会执行不同的操作，项目的清理、校验、编译、测试、打包、检查、安装、发布等多个阶段。

- 生命周期

  | 阶段名称                 | 作用                                                         |
  | ------------------------ | ------------------------------------------------------------ |
  | clean（清理阶段）        | 清理上一次编译生成的文件，会将target文件夹删除，只保留源代码和配置文件 |
  | validate（验证阶段）     | 验证工程是否正确，所有需要的资源是否可用                     |
  | compile（编译阶段）      | 对源代码进行编译，将生成结果放在target下                     |
  | test（测试阶段）         | 执行test/java下的测试代码                                    |
  | package（打包阶段）      | 将项目打包生成.jar或.war文件，存储在target目录中             |
  | verify（检查阶段）       | 运行.jar或.war文件中的所有测试，验证包是否完好               |
  | install（安装阶段）      | 把包安装到maven本地仓库，可以被其他工程作为依赖使用          |
  | site（生成站点文档阶段） | 生成项目报告、依赖文档到target目录中                         |
  | deploy（发布阶段）       | 将项目站点发布到服务器                                       |

- 在idea右上角的Lefecycle目录中可以找到每个生命周期对应的执行按钮，可以双击执行进行测试

  ![](/Users/jinzhanqing/机构/maven/image/image_WOiglAGuJW.png)

   注意：在运行生命周期工具时，maven会将所需插件下载到Plugins目录中，有些情况下可能因为缺少插件而无法运行

### 九、使用Maven开发Web项目步骤与目录规范

#### （一）开发步骤

```markdown
1. 搭建开发环境，检查maven配置，新建maven项目，选择maven-archetype-webapp骨架（目录结构）设置坐标
2. 补全目录结构
3. 配置pom.xml，修改编码方式，查询坐标，导入依赖
4. 建表
5. 实体类：目标位置src/main/com/baizhi/entity
6. 配置文件：目标位置src/main/resources （jdbc.properties）
7. 工具类：目标位置 src/main/com/baizhi/util
8. dao接口：目标位置 src/main/com/baizhi/dao
9. dao实现类：目标位置 src/main/com/baizhi/dao/impl
10. service接口：目标位置src/main/com/baizhi/service
11. service实现类：目标位置 src/main/com/baizhi/service/impl
12. 测试类：目标位置：src/test/java/com/baizhi/test
13. comtroller：目标位置src/main/com/baizhi/controller
14. html：目标位置src/main/webapp
15. 部署服务器，集成测试
```

#### （二）目录规范

- 示例

  ![](/Users/jinzhanqing/机构/maven/image/image_dqZZx7cEFe.png)

  idea中完整的web项目结构

  ![](/Users/jinzhanqing/机构/maven/image/image_4RWhsUVnNj.png)

#### (三）web项目基础pom.xml配置

- pom.xml：

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <project xmlns="http://maven.apache.org/POM/4.0.0"
           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
           xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
      <modelVersion>4.0.0</modelVersion>
  
      <groupId>com.baizhi</groupId>
      <artifactId>maven_struts2</artifactId>
      <version>1.0-SNAPSHOT</version>
  
      <properties>
          <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
          <maven.compiler.source>8</maven.compiler.source>
          <maven.compiler.target>8</maven.compiler.target>
      </properties>
  
     
      <dependencies>
      
          <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.11</version>
            <scope>test</scope>
          </dependency>
  
          <dependency>
              <groupId>mysql</groupId>
              <artifactId>mysql-connector-java</artifactId>
              <version>5.1.47</version>
            </dependency>
      
          <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>javax.servlet-api</artifactId>
            <version>3.1.0</version>
            <scope>provided</scope>
          </dependency>
      
          <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.14.2</version>
          </dependency>
  
          <dependency>
              <groupId>org.projectlombok</groupId>
              <artifactId>lombok</artifactId>
              <version>1.18.24</version>
          </dependency>
  
      </dependencies>
   
  </project>
  ```

## Mybatis

### 一、MyBatis简介

-   MyBatis原来为ibatis，是一个持久层（dao层）框架，提供了简便的操作数据库的功能，是对原生的jdbc技术的封装，用来解决原生的jdbc技术访问数据库所带来的一些问题。
-   jdbc访问数据库存在的问题
    1.  代码冗余大（对于不同的表的dao实现类，只有sql命令是不同的）
    2.  手动的ORM（查询时，将数据库中的字段转换成对象中属性）映射，比较繁琐。
    3.  没有对查询进行优化，不支持缓存。

### 二、Mybatis相关配置文件简介

1. log4j配置文件
   作用：开启log4j的日志功能，用于记录在mybatis的执行过程，方便调错
   导入位置：src/main/resources根目录下（规定）

   [log4j.properties](file/log4j_wPlDdz8-p1.properties "log4j.properties")

2. mybatis-config.xml
   作用：对于mybatis核心配置文件，配置数据链接等相关参数
   导入位置：随意，但是建议放在src/main/resources根目录下（规范）

   [mybatis-config.xml](file/mybatis-config_rpVcIxjFhC.xml "mybatis-config.xml")

3. mybatis-mapper映射文件，编写sql语句，映射Dao接口
   作用：定义dao接口要执行的sql语句，和dao接口一一对应
   导入位置：随意，建议放在dao包中，放在src/main/resources/com/baizhi/dao（规范）

   [xxxxMapper.xml](file/xxxxMapper_LCX8rI0nHV.xml "xxxxMapper.xml")



### 三、Mybatis核心类与接口

| 类名/接口名       | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| Resource          | 读取配置文件中的内容                                         |
| &#xA;SqlSession   | 对Connection对象的封装，表示一条数据库链接&#xA;可以获取dao接口实现类对象&#xA;可以通过commit()或rollback()控制事务 |
| SqlSessionFactory | 用于创建SqlSession的工具类                                   |

### 四、Mybatis开发步骤

#### （一）创建Maven项目在pom.xml中引入依赖

```xml
 <!--引入mybatis相关依赖-->
    <dependencies>
        <!--  mybatis相关依赖 -->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis</artifactId>
            <version>3.5.4</version>
        </dependency>

        <!-- log4j 日志框架，负责将执行过程输入到控制台中便于调错-->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-log4j12</artifactId>
            <version>1.7.30</version>
        </dependency>

        <!-- mysql -->
        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
            <version>8.0.27</version>
        </dependency>

        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>4.11</version>
            <scope>test</scope>
        </dependency>
        
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.24</version>
        </dependency>
        
    </dependencies>
```

#### （二）拷贝配置文件到指定目录中

![](/Users/jinzhanqing/机构/mybatis_day1 -基本使用/image/image_Cn6DFJ-R-o.png)

#### （三）在mybatis-confg.xml配置文件中添加环境配置

```xml
<!--总环境配置（唯一）：-->
  <!--default：默认使用的环境id与某个environment中的id一致-->
  <environments default="mysql_conn">
    <!--环境配置（可配置多个）：-->
    <!--id：此环境的唯一标识（自定义）-->
    <environment id="mysql_conn">
      <!--事务控制方式：-->
      <!--type="JDBC" ：手动控制事务-->
      <!--type="MANAGED"：委托其他框架进行控制-->
      <transactionManager type="JDBC"/>
      <!--数据库链接配置：-->
      <!--type="POOLED"：使用连接池-->
      <!--type="UNPOOLED:不使用连接池"-->
      <dataSource type="POOLED">
        <!--链接参数-->
        <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
        <!-- 注意将链接参数中的&符号替换为&amp; -->
        <property name="url" value="jdbc:mysql://localhost:3306/数据库名称?useUnicode=true&amp;characterEncoding=UTF-8&amp;uesSSL=false&amp;serverTimezone=Asia/Shanghai"/>
        <property name="username" value="用户名"/>
        <property name="password" value="密码"/>
      </dataSource>
    </environment>
  </environments>
```

#### （四）测试能否创建SqlSession

1. 新建测试类

2. 在测试类中通过SqlSessionFactory获取SqlSession

   ```java
   //1.读取mybatis-config.xml
   InputStream is = Resources.getResourceAsStream("mybatis-config.xml配置文件路径");
   //2.获取SqlSessionFactory对象
   SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build( is );
   //3.创建sqlSession
   SqlSession session = ssf.openSession();
   System.out.println( session );
   ```

   如果此时程序没有报错，则证明创建成功

#### （五）建表并设计实体类

- 表：

  ```sql
  CREATE TABLE t_person (
    id int primary key auto_increment,
    name varchar(20),
    sex varchar(5) ,
    mobile varchar(30) ,
    address varchar(255),
    date birthday;
  );
  ```

- 实体类：（注意：属性名此时应与列名一致）

  ```java
  @Data
  @AllArgsConstructor
  @NoArgsConstructor
  public class Person {
      private Integer id;
      private String name;
      private String sex;
      private String mobile;
      private String address;
      private Date birthday;
  }
  ```

#### （六）设计dao接口

- dao接口

  ```java
  public interface PersonDao{
      public List<Person> selectAllPerson();
  }
  ```

#### （七）引入mapper.xml配置文件并注册

1. 在resource目录新建com.baizhi.dao包

2. 将xxxMapper.xml导入com.baizhi.dao包
   xxxMapper.xml文件命名规则：

   ```markdown
   dao接口名称Mapper .xml
   ```

3. 在xxxMapper.xml进行配置

   ```xml
   <mapper namespace="dao接口的全限定名">
       <select id="方法名" resultType="返回值类型,全限定名,如果是集合类型则写集合中元素的类型">
           sql语句
       </select>
   </mapper>
   
   ```

   例：

   ```xml
   <mapper namespace="com.baizhi.dao.PersonDao">
       <select id="selectAllPerson" resultType="com.baizhi.entity.Person">
           select * from t_person;
       </select>
   </mapper>
   ```

   xxxMapper.xml文件表示一个dao接口的实现类，其中select标签对应接口中的一个查询方法，今后我们不必再为dao接口提供任何实现类，只需要提供对应的Mapper文件即可

4. 在mybatis-config.xml配置文件中注册mapper文件

   ```xml
   <!-- 配置mapper文件所在的位置 -->
   <mappers>
       <mapper resource="mapper文件所在路径"/>
   </mappers>
   ```

   例：

   ```xml
   <mappers>
       <!-- 注意路径名称和包名的区别 -->
       <mapper resource="com/baizhi/dao/PersonMapper.xml"/>
   </mappers>
   ```

#### （八）测试dao功能

```java
//1. 读取mybatis-config.xml配置文件
InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
//2. 创建SqlSessionFactory
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
//3. 创建sqlSession
SqlSession sqlSession = sqlSessionFactory.openSession();
//4. 获取dao接口的实现类对象
PersonDao personDao = sqlSession.getMapper(PersonDao.class);
//5. 调用dao方法
List<Person> ps = personDao.selectAllPerson();
//遍历输出结果
ps.forEach(System.out::println);
//6. 关闭资源
sqlSession.close();
```

### 五、开发步骤小结

```markdown
1. 创建Maven项目，导入相关依赖
2. 拷贝mybatis-config.xml与log4j.xml配置文件到resources目录中
3. 在mybatis-config.xml中添加环境配置
4. 测试能否创建SqlSession
5. 建表并设计实体类
6. 设计dao接口
7. 引入mapper.xml文件，每个mapper文件对应一个dao接口，该文件应放在resources/com/baizhi/dao中
8. 测试dao功能

```

如果`dao`接口中增加新的方法，只需要在`mapper.xml`添加配置即可
如果增加新的`dao`，则需要创建一个新的`mapper.xml`并在`mybatis-config.xml`中进行注册

### 六、mapper.xml映射文件基础标签

-   作用：在mybatis中，一个`mapper.xml`配置文件对应一个`dao`接口，mybatis会读取`mapper.xml`文件从而动态的为我们生成`dao`接口的实现类，因此我们不需要手动提供`dao`接口实现。

#### （一）mapper.xml中的CRUD标签

| 标签       | 作用                                |      |
| ---------- | ----------------------------------- | ---- |
| `<select>` | 查询标签，对应dao中一个查询方法     |      |
| `<insert>` | 插入标签，对应dao中一个添加的方法   |      |
| `<delete>` | 删除一标签，对应dao中一个删除的方法 |      |
| `<update>` | 更新标签，对应dao中一个更新的方法   |      |

#### （二）resultType与parameterType属性

- resultType属性作用于`<select>`标签，表示查询返回的结果类型
  如果返回的是8种基本数据类型，直接写类型名称，例如int、long
  如果返回的是对象类型，需要写类的全限定名
  如果返回的是集合类型，需要写元素的权限定名
  例：

  ```xml
  <select id="xxx" resultType="int"></select> <!-- 返回值类型为int -->
  <select id="xxx" resultType="java.util.Date"></select><!-- 返回值类型为java.util.Date-->
  <select id="xxx" resultType="com.baizhi.User"></select><!-- 返回值类型为User或者User集合-->
  ```

- parameterType属性为通用属性，四个标签中都可以使用该属性，表示参数的类型
  如果参数是8种基本数据类型，直接写类型名称
  如果参数类型为对象类型，需要写类的权限定名
  如果方法有多个参数，此时不使用parameterType
  例：

  ```xml
  <delete id="xxx" parameterType="int"></delete><!-- 参数类型为int -->
  <select id="xxx" parameterType="double"></select><!-- 参数类型为double -->
  <update id="xxx" parameterType="com.baizhi.Person"> </update><!-- 参数类型为Person -->
  ```

### 七、Mybatis参数绑定

-   作用：在sql语句中使用方法参数

#### （一）使用基本数据类型、String类型参数

- dao接口方法：

  ```java
  public void deletePersonById(int id);//根据id删除联系人
  public List<Person> selectPersonByName(String name);//根据姓名查询联系人
  public void deletePersonBySexAndAge(String sex,int age);//根据性别、年龄删除联系人
  ```

- 在Dao中使用@Param注解绑定参数，供配置文件中使用
  语法：

  ```java
  访问权限修饰符 返回值类型  方法名(@Param("自定义名称")数据类型 参数名1 , @Param("自定义名称")数据类型 参数名2....);
  ```

   注意：自定义名称与参数名可以不同，但不可重复、进行增删改查操作时需要使用`SqlSession`中的`commit()`方法提交事务。

  ```java
  public void deletePersonById(@Param("id") int id);//根据id删除联系人
  public List<Person> selectPersonByName(@Param("name") String name);//根据姓名查询联系人
  public void deletePersonBySexAndAge(@Param("sex") String sex,@Param("age") int age);//根据性别、年龄删除联系人
  ```

- 在配置文件中使用`#{自定义名称}`获取方法参数
  例：`deletePersonId`方法配置

  ```xml
  <delete id="deletePersonById" parameterType="int">
      delete from t_person where id = #{id};
  </delete>
  ```

- 例：`selectPersonByName`方法配置

  ```xml
  <select id="selectPersonByName" parameterType="String" resultType="com.baizhi.entity.Person">
         select * from  t_person where name = #{name};
  </select>
  ```

- 例：`deletePersonBySexAndAge`方法配置

  ```xml
  <delete id="deletePersonBySexAndAge">
         delete from t_person where sex=#{sex} and age=#{age};
  </delete>
  
  ```

- 参数绑定示意：

  ![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_AAI6Q0xZ8f.png)

#### （二）使用对象类型参数

- dao接口方法

  ```java
  public void insertPerson(@Param("p") Person person);
  ```

- PersonMapper.xml中获取属性的语法：

  ```xml
  #{自定义名称.属性名}
  ```

- `PersonMapper.xml`中的配置，使用`#{自定义名称.属性名称}`表示要使用的属性

  ```xml
  <insert id="insertPerson" parameterType="com.baizhi.entity.Person">
          insert into t_person values( #{p.id} , #{p.name} , #{p.age} , #{p.sex} ,#{p.mobile} , #{p.address} , #{p.birthday});
  </insert>
  ```

- 测试代码

  ```java
  //1.读取mybatis-config.xml
  InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
  //2.获取SqlSessionFactory对象
  SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build( is );
  //3.创建sqlSession
  SqlSession session = ssf.openSession();
  //4.获取PersonDao
  PersonDao personDao = session.getMapper(PersonDao.class);
  //5.创建对象，执行插入方法
  Person person = new Person(null,"yangdd",18,"男","18977545542","河北省邯郸市",new Date());
  personDao.insertPerson( person );
  //6.提交事务
  session.commit();
  //7.关闭链接
  session.close();
  ```

### 八、MyBatis工具类的封装

- 模仿JDBCUtils提供方便获取SqlSession的方式

- 代码示例

  ```java
  public class MybatisUtils {
      private static SqlSessionFactory sqlSessionFactory;
      //ThreadLocal确保每个线程能够使用独立的SqlSession
      private static ThreadLocal<SqlSession> tl = new ThreadLocal<>();
      //静态代码块，初始化SqlSessionFactory
      static{
          //try-with-resources语句结构，创建SqlSessionFactory
          try (InputStream is = Resources.getResourceAsStream("mybatis-config.xml");){
              //1.读取mybatis-config.xml配置文件
              //2. 创建sqlSessionFactory
              sqlSessionFactory = new SqlSessionFactoryBuilder().build(is);
          }catch (Exception e){
              e.printStackTrace();
          }
      }
  
      //获取sqlSession的方法
      public static SqlSession getSqlSession(){
          //尝试从ThreadLocal中获取SqlSession
          SqlSession sqlSession = tl.get();
          try{
              if(sqlSession==null) {
                  //创建sqlSession
                   sqlSession= sqlSessionFactory.openSession();
                   //将session对象存入ThreadLocal
                   tl.set( sqlSession );
              }
  
          }catch (Exception e){
              e.printStackTrace();
              throw new RuntimeException(e);
          }
          return sqlSession;
      }
      //关闭session的方法
      public static void close(){
          SqlSession sqlSession = getSqlSession();
          if(sqlSession != null){
              sqlSession.close();
              tl.remove();
          }
      }
  }
  ```

### 九、Mybatis整合与事务控制

- Mybatis在整个程序体系结构中只负责替换原有JDBC代码例如数据库的CRUD操作，事务控制等，不影响传统的Servlet代码也不影响Dao、Service接口的设计

  ![](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_57Ba1MdGcx.png)

- 两者在实现Dao接口时的对比

  ![image_mydmfxHbgj](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_mydmfxHbgj.png)

- Mybatis控制事务的方法
  通过SqlSession中的`commit()`方法提交事务，通过`rollback()`方法回滚事务

- 两者在实现Service接口时的对比


![image_4IUk8MHCuf](https://raw.githubusercontent.com/Better-Bclear/pic/main/image_4IUk8MHCuf.png)



